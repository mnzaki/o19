//! Service-side implementation of FoundframeRadicle
//!
//! This uses JNI to bridge between Android Java Service and Rust.
//! 
//! Architecture:
//! - Android Java Service (FoundframeRadicleService.java) creates the service
//! - Java calls native methods (nativeGetNodeId, nativeAddPost, etc.)
//! - These JNI functions are generated by aidl-codegen
//! - They dispatch to the `FoundframeRadicle` trait implementation

use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// Include the generated JNI glue
// This will be generated by aidl-codegen in build.rs
// include!(concat!(env!("OUT_DIR"), "/generated/jni_glue.rs"));

/// Your service implementation - implements the trait from generated code
pub struct FoundframeService {
    foundframe: Mutex<Option<o19_foundframe::Foundframe>>,
    config: Mutex<Config>,
    callbacks: Mutex<HashMap<u64, Box<dyn Fn(&str, &str) + Send>>>,
    callback_counter: Mutex<u64>,
}

#[derive(Clone, Debug)]
struct Config {
    radicle_home: String,
    node_alias: String,
}

impl FoundframeService {
    pub fn new(radicle_home: String, node_alias: String) -> Self {
        Self {
            foundframe: Mutex::new(None),
            config: Mutex::new(Config { radicle_home, node_alias }),
            callbacks: Mutex::new(HashMap::new()),
            callback_counter: Mutex::new(0),
        }
    }

    /// Initialize the foundframe backend (call this before using the service)
    pub fn init_foundframe(&self) -> Result<(), Box<dyn std::error::Error>> {
        let config = self.config.lock().unwrap();
        
        // TODO: Initialize your foundframe instance here
        // let foundframe = o19_foundframe::Foundframe::new(&config.radicle_home, &config.node_alias)?;
        // *self.foundframe.lock().unwrap() = Some(foundframe);
        
        log::info!("Foundframe initialized: {} / {}", config.radicle_home, config.node_alias);
        Ok(())
    }
}

// Implementation of the trait methods
// These will be called by the generated JNI glue
impl FoundframeService {
    pub fn get_node_id(&self) -> Result<String, Box<dyn std::error::Error>> {
        // TODO: Implement - get from foundframe
        Ok("test-node-id".to_string())
    }

    pub fn is_node_running(&self) -> Result<bool, Box<dyn std::error::Error>> {
        // TODO: Implement - check foundframe state
        Ok(self.foundframe.lock().unwrap().is_some())
    }

    pub fn get_node_alias(&self) -> Result<String, Box<dyn std::error::Error>> {
        let config = self.config.lock().unwrap();
        Ok(config.node_alias.clone())
    }

    pub fn create_repository(&self, name: &str) -> Result<bool, Box<dyn std::error::Error>> {
        log::info!("Creating repository: {}", name);
        // TODO: Implement with foundframe
        Ok(true)
    }

    pub fn list_repositories(&self) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        // TODO: Implement with foundframe
        Ok(vec![])
    }

    pub fn follow_device(&self, device_id: &str) -> Result<bool, Box<dyn std::error::Error>> {
        log::info!("Following device: {}", device_id);
        // TODO: Implement
        Ok(true)
    }

    pub fn list_followers(&self) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        // TODO: Implement
        Ok(vec![])
    }

    pub fn generate_pairing_code(&self) -> Result<String, Box<dyn std::error::Error>> {
        // TODO: Implement - generate a pairing code
        Ok("PAIR-123456".to_string())
    }

    pub fn confirm_pairing(&self, device_id: &str, code: &str) -> Result<bool, Box<dyn std::error::Error>> {
        log::info!("Confirming pairing: {} / {}", device_id, code);
        // TODO: Implement
        Ok(true)
    }

    pub fn unpair_device(&self, device_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        log::info!("Unpairing device: {}", device_id);
        // TODO: Implement
        Ok(())
    }

    pub fn add_post(&self, content: &str, title: &str) -> Result<String, Box<dyn std::error::Error>> {
        log::info!("Adding post: {} / {}", title, content);
        // TODO: Implement - returns PKB URL
        Ok("radicle://post/123".to_string())
    }

    pub fn add_bookmark(&self, url: &str, title: &str, notes: &str) -> Result<String, Box<dyn std::error::Error>> {
        log::info!("Adding bookmark: {} / {}", title, url);
        // TODO: Implement
        Ok("radicle://bookmark/123".to_string())
    }

    pub fn add_media_link(&self, directory: &str, url: &str, title: &str, 
                          mime_type: &str, subpath: &str) -> Result<String, Box<dyn std::error::Error>> {
        log::info!("Adding media: {} / {}", title, url);
        // TODO: Implement
        Ok("radicle://media/123".to_string())
    }

    pub fn add_person(&self, display_name: &str, handle: &str) -> Result<String, Box<dyn std::error::Error>> {
        log::info!("Adding person: {} / {}", display_name, handle);
        // TODO: Implement
        Ok("radicle://person/123".to_string())
    }

    pub fn add_conversation(&self, conversation_id: &str, title: &str) -> Result<String, Box<dyn std::error::Error>> {
        log::info!("Adding conversation: {} / {}", title, conversation_id);
        // TODO: Implement
        Ok("radicle://conversation/123".to_string())
    }

    pub fn add_text_note(&self, directory: &str, content: &str, title: &str, 
                         subpath: &str) -> Result<String, Box<dyn std::error::Error>> {
        log::info!("Adding text note: {} in {}", title, directory);
        // TODO: Implement
        Ok("radicle://note/123".to_string())
    }

    pub fn subscribe_events<F>(&self, callback: F) -> Result<(), Box<dyn std::error::Error>>
    where
        F: Fn(&str, &str) + Send + 'static,
    {
        let mut counter = self.callback_counter.lock().unwrap();
        let id = *counter;
        *counter += 1;
        
        let mut callbacks = self.callbacks.lock().unwrap();
        callbacks.insert(id, Box::new(callback));
        
        log::info!("Event subscription added: {}", id);
        Ok(())
    }

    pub fn unsubscribe_events(&self, id: u64) -> Result<(), Box<dyn std::error::Error>> {
        let mut callbacks = self.callbacks.lock().unwrap();
        callbacks.remove(&id);
        log::info!("Event subscription removed: {}", id);
        Ok(())
    }

    /// Notify all subscribers of an event
    pub fn notify_event(&self, event_type: &str, event_data: &str) {
        let callbacks = self.callbacks.lock().unwrap();
        for (id, callback) in callbacks.iter() {
            log::debug!("Notifying subscriber {}: {} / {}", id, event_type, event_data);
            callback(event_type, event_data);
        }
    }
}

// Make it thread-safe for JNI
unsafe impl Send for FoundframeService {}
unsafe impl Sync for FoundframeService {}

// Global service instance - initialized when the service starts
use std::sync::OnceLock;
static SERVICE_INSTANCE: OnceLock<Arc<FoundframeService>> = OnceLock::new();

/// Initialize the global service instance
pub fn init_service(radicle_home: String, node_alias: String) -> Arc<FoundframeService> {
    let service = Arc::new(FoundframeService::new(radicle_home, node_alias));
    let _ = SERVICE_INSTANCE.set(service.clone());
    service
}

/// Get the global service instance
pub fn get_service() -> Option<Arc<FoundframeService>> {
    SERVICE_INSTANCE.get().cloned()
}

/// JNI entry point - called from Java when service starts
#[no_mangle]
pub extern "C" fn Java_ty_circulari_o19_service_FoundframeRadicleService_nativeStartService(
    mut env: jni:: JNIEnv,
    _class: jni::objects::JClass,
    radicle_home: jni::objects::JString,
    node_alias: jni::objects::JString,
) {
    android_log::info("RUST", "nativeStartService entered");
    
    o19_foundframe::setup_logging();
    android_log::info("RUST", "Logging initialized");
    
    // Convert JNI strings to Rust
    let radicle_home: String = env
        .get_string(&radicle_home)
        .expect("Invalid radicle_home")
        .into();
    let node_alias: String = env
        .get_string(&node_alias)
        .expect("Invalid node_alias")
        .into();
    
    android_log::info("RUST", &format!("Config: {} / {}", radicle_home, node_alias));
    
    // Create and initialize service
    let service = init_service(radicle_home, node_alias);
    if let Err(e) = service.init_foundframe() {
        android_log::info("RUST", &format!("Failed to initialize foundframe: {}", e));
    } else {
        android_log::info("RUST", "Service initialized and ready");
    }
    
    // Note: No need for the thread pool loop - JNI calls come on Binder threads
}

/// JNI helper for individual method calls
/// Each AIDL method will have a corresponding JNI function
/// These will be generated by aidl-codegen, but here's an example using macros:

// Using the macro system (simplified example):
// define_jni_method! {
//     ty.circulari.o19.IFoundframeRadicle_Stub,
//     nativeGetNodeId() -> String,
//     |service| { service.get_node_id() }
// }

// Manual implementation for now:
#[no_mangle]
pub extern "C" fn Java_ty_circulari_o19_IFoundframeRadicle_Stub_nativeGetNodeId(
    mut env: jni:: JNIEnv,
    _class: jni::objects::JClass,
) -> jni::sys::jstring {
    let service = crate::with_service_or_throw!(env);
    let result = service.get_node_id();
    crate::jni_ret!(env, result => String)
}

// Android logging helper
#[cfg(target_os = "android")]
mod android_log {
    use std::ffi::CString;
    
    pub fn info(tag: &str, msg: &str) {
        extern "C" { fn __android_log_write(prio: i32, tag: *const u8, text: *const u8) -> i32; }
        const LOG_INFO: i32 = 4;
        let t = CString::new(tag).unwrap_or_default();
        let m = CString::new(msg).unwrap_or_default();
        unsafe { __android_log_write(LOG_INFO, t.as_ptr() as *const u8, m.as_ptr() as *const u8); }
    }
}

#[cfg(not(target_os = "android"))]
mod android_log {
    pub fn info(_tag: &str, _msg: &str) {}
}
