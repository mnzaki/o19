// GENERATED BY SPIRE-LOOM - DO NOT EDIT (even if LLM)
// 
// This file is automatically generated from a template.
// Changes will be overwritten on next generation.
// 
// Template: node_modules/@o19/spire-loom/machinery/bobbin/tauri/lib.rs.ejs
// Template file: lib.rs.ejs
// To override: Copy this template to loom/bobbin/tauri/lib.rs.ejs
// 
// To modify the generated output, edit the template file above.
//! o19-RustExternalLayer-tauri - GENERATED by spire-loom
//!
//! Tauri plugin helper for RustExternalLayer platform integration.
//! 
//! Usage in your plugin:
//! ```rust
//! use tauri::plugin::{Builder, TauriPlugin};
//! 
//! pub fn init<R: Runtime>() -> TauriPlugin<R> {
//!   Builder::new("my-plugin")
//!     // Commands are auto-injected by spire-loom into generate_handler!
//!     .invoke_handler(tauri::generate_handler![my_custom_command])
//!     .setup(|app, api| {
//!       // Setup spire platform
//!       let RustExternalLayer = crate::spire::setupSpireRustExternalLayer(app, &api)?;
//!       
//!       // Your additional setup...
//!       Ok(())
//!     })
//!     .build()
//! }
//! ```
//!
//! Muxing: This plugin supports multiple platform implementations
//! - #[cfg(desktop)] → DesktopPlatform (direct RustExternalLayer calls)
//! - #[cfg(mobile)] → MobilePlatform (JNI calls to Android service)

use serde::de::DeserializeOwned;
use std::sync::Arc;
use tauri::{
  AppHandle, Manager, Runtime,
  plugin::{Builder, TauriPlugin, PluginApi},
};
use tracing::info;

pub use self::models::*;
pub use self::platform::SpireRustExternalLayerPlatformTrait;

pub mod commands;
pub mod error;
pub mod extension;
pub mod models;
pub mod platform;

pub use extension::SpireRustExternalLayerExt;
pub use error::{Error, Result};

/// Platform struct that contains all RustExternalLayer state.
/// 
/// This is the main handle users interact with after setup.
pub struct SpireRustExternalLayerPlatform {
  platform: Arc<dyn SpireRustExternalLayerPlatformTrait>,
}

impl SpireRustExternalLayerPlatform {
  /// Setup the platform and manage it on the app handle.
  /// 
  /// Call this from your plugin's setup function.
  pub fn setup<R: Runtime, C: DeserializeOwned>(
    app: &AppHandle<R>,
    api: &PluginApi<R, C>,
  ) -> Result<Self> {
    info!("Setting up SpireRustExternalLayerPlatform...");

    // Initialize platform implementation (muxing happens here)
    #[cfg(mobile)]
    let platform = Arc::new(mobile::init(app, api)?) as Arc<dyn SpireRustExternalLayerPlatformTrait>;
    #[cfg(desktop)]
    let platform = Arc::new(desktop::init(app, api)?) as Arc<dyn SpireRustExternalLayerPlatformTrait>;

    // Manage the platform so extension trait can access it
    app.manage(platform.clone());

    info!("SpireRustExternalLayerPlatform setup complete");
    Ok(Self { platform })
  }

  /// Get a reference to the platform implementation.
  pub fn platform(&self) -> &dyn SpireRustExternalLayerPlatformTrait {
    &*self.platform
  }
}

/// Convenience function for setup.
/// 
/// Returns the platform handle for direct access.
pub fn setupSpireRustExternalLayer<R: Runtime, C: DeserializeOwned>(
  app: &AppHandle<R>,
  api: &PluginApi<R, C>,
) -> Result<SpireRustExternalLayerPlatform> {
  SpireRustExternalLayerPlatform::setup(app, api)
}

// ============================================================================
// Platform-specific implementations
// ============================================================================

#[cfg(desktop)]
mod desktop;
#[cfg(mobile)]
mod mobile;
