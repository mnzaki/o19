// GENERATED BY SPIRE-LOOM - DO NOT EDIT (even if LLM)
// 
// This file is automatically generated from a template.
// Changes will be overwritten on next generation.
// 
// Template: tauri/foundframe_radicle_client.kt.ejs
// Template file: foundframe_radicle_client.kt.ejs
// This is a custom template in your workspace
// 
// To modify the generated output, edit the template file above.
package ty.circulari.o19.service

import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.ServiceConnection
import android.os.IBinder
import android.os.RemoteException
import android.util.Log
import ty.circulari.o19.IFoundframeRadicle

/**
 * FoundframeRadicleClient - Generated service client for AIDL IPC
 *
 * This client binds to the FoundframeRadicleService (running in :foundframe process)
 * and provides typed methods for all AIDL operations.
 *
 * Usage:
 * ```kotlin
 * val client = FoundframeRadicleClient(context)
 * client.ensureStarted()  // Start the service first
 * client.connect { success ->
 *     if (success) {
 *         val result = client.addBookmark(url, title, notes)
 *     }
 * }
 * ```
 *
 * Security: Requires caller to have permission:
 *   ty.circulari.o19.ACCESS_FOUNDFRAME
 */
class FoundframeRadicleClient(private val context: Context) {
    
    companion object {
        private const val TAG = "FoundframeRadicleClient"
        private const val SERVICE_PACKAGE = "ty.circulari.o19"
        private const val SERVICE_CLASS = "ty.circulari.o19.service.FoundframeRadicleService"
        
        /**
         * Permission required to bind to the service.
         * This is a signature-level permission - only apps signed with the same
         * certificate can bind.
         */
        const val PERMISSION = "ty.circulari.o19.ACCESS_FOUNDFRAME"
    }
    
    private var service: IFoundframeRadicle? = null
    private var isConnected = false
    
    private val connection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, binder: IBinder?) {
            Log.i(TAG, "Connected to FoundframeRadicleService")
            service = IFoundframeRadicle.Stub.asInterface(binder)
            isConnected = true
        }
        
        override fun onServiceDisconnected(name: ComponentName?) {
            Log.i(TAG, "Disconnected from FoundframeRadicleService")
            service = null
            isConnected = false
        }
    }
    
    /**
     * Bind to the FoundframeRadicleService.
     *
     * The service must already be running (started) before binding.
     * Call [ensureStarted] first to start the service.
     *
     * @return true if bind request was sent successfully
     */
    fun connect(): Boolean {
        if (isConnected) {
            Log.d(TAG, "Already connected")
            return true
        }
        
        val intent = Intent().apply {
            setClassName(SERVICE_PACKAGE, SERVICE_CLASS)
        }
        
        return try {
            context.bindService(intent, connection, Context.BIND_AUTO_CREATE).also {
                if (!it) {
                    Log.e(TAG, "bindService returned false")
                }
            }
        } catch (e: SecurityException) {
            Log.e(TAG, "SecurityException: Missing $PERMISSION permission")
            false
        } catch (e: Exception) {
            Log.e(TAG, "Failed to bind: ${e.message}")
            false
        }
    }
    
    /**
     * Unbind from the service.
     * Safe to call even if not connected.
     */
    fun disconnect() {
        if (isConnected) {
            try {
                context.unbindService(connection)
            } catch (e: IllegalArgumentException) {
                // Service was already unbound
                Log.w(TAG, "Service already unbound")
            }
            isConnected = false
            service = null
        }
    }
    
    /**
     * Ensure the service is started before binding.
     *
     * For apps with the same signing key, this works via the signature permission.
     * The service will run in its own process (:foundframe).
     *
     * @param alias Node alias for the service
     * @return true if start request was sent successfully
     */
    fun ensureStarted(alias: String = "android"): Boolean {
        val intent = Intent().apply {
            setClassName(SERVICE_PACKAGE, SERVICE_CLASS)
            putExtra("alias", alias)
        }
        return try {
            context.startService(intent)
            Log.i(TAG, "Started FoundframeRadicleService with alias=$alias")
            true
        } catch (e: SecurityException) {
            Log.e(TAG, "SecurityException: Missing $PERMISSION permission")
            false
        } catch (e: Exception) {
            Log.e(TAG, "Failed to start: ${e.message}")
            false
        }
    }
    
    /**
     * Check if connected to the service.
     */
    fun isConnected(): Boolean = isConnected
    
    // Generated convenience methods
    
    /**
     * BookmarkMgmt.bookmark_addBookmark
     *
     * @param url url
     * @param title title
     * @param notes notes
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun bookmark_add_bookmark(url: undefined, title: undefined, notes: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.bookmark_add_bookmark(url, title, notes)
    }
    
    /**
     * BookmarkMgmt.bookmark_getBookmarkByUrl
     *
     * @param pkbUrl pkbUrl
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun bookmark_get_bookmark_by_url(pkbUrl: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.bookmark_get_bookmark_by_url(pkbUrl)
    }
    
    /**
     * BookmarkMgmt.bookmark_listBookmarks
     *
     * @param directory directory
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun bookmark_list_bookmarks(directory: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.bookmark_list_bookmarks(directory)
    }
    
    /**
     * BookmarkMgmt.bookmark_deleteBookmark
     *
     * @param pkbUrl pkbUrl
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun bookmark_delete_bookmark(pkbUrl: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.bookmark_delete_bookmark(pkbUrl)
    }
    
    /**
     * ConversationMgmt.conversation_addConversation
     *
     * @param conversationId conversationId
     * @param title title
     * @param participants participants
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun conversation_add_conversation(conversationId: undefined, title: undefined, participants: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.conversation_add_conversation(conversationId, title, participants)
    }
    
    /**
     * ConversationMgmt.conversation_getConversation
     *
     * @param conversationId conversationId
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun conversation_get_conversation(conversationId: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.conversation_get_conversation(conversationId)
    }
    
    /**
     * ConversationMgmt.conversation_listConversations
     *
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun conversation_list_conversations():  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.conversation_list_conversations()
    }
    
    /**
     * ConversationMgmt.conversation_updateConversation
     *
     * @param conversationId conversationId
     * @param title title
     * @param participants participants
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun conversation_update_conversation(conversationId: undefined, title: undefined, participants: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.conversation_update_conversation(conversationId, title, participants)
    }
    
    /**
     * ConversationMgmt.conversation_deleteConversation
     *
     * @param conversationId conversationId
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun conversation_delete_conversation(conversationId: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.conversation_delete_conversation(conversationId)
    }
    
    /**
     * ConversationMgmt.conversation_addParticipant
     *
     * @param conversationId conversationId
     * @param personHandle personHandle
     * @param role role
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun conversation_add_participant(conversationId: undefined, personHandle: undefined, role: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.conversation_add_participant(conversationId, personHandle, role)
    }
    
    /**
     * ConversationMgmt.conversation_removeParticipant
     *
     * @param conversationId conversationId
     * @param personHandle personHandle
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun conversation_remove_participant(conversationId: undefined, personHandle: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.conversation_remove_participant(conversationId, personHandle)
    }
    
    /**
     * ConversationMgmt.conversation_listParticipants
     *
     * @param conversationId conversationId
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun conversation_list_participants(conversationId: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.conversation_list_participants(conversationId)
    }
    
    /**
     * ConversationMgmt.conversation_addConversationMedia
     *
     * @param conversationId conversationId
     * @param mediaUrl mediaUrl
     * @param context context
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun conversation_add_conversation_media(conversationId: undefined, mediaUrl: undefined, context: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.conversation_add_conversation_media(conversationId, mediaUrl, context)
    }
    
    /**
     * ConversationMgmt.conversation_removeConversationMedia
     *
     * @param conversationId conversationId
     * @param mediaUrl mediaUrl
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun conversation_remove_conversation_media(conversationId: undefined, mediaUrl: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.conversation_remove_conversation_media(conversationId, mediaUrl)
    }
    
    /**
     * ConversationMgmt.conversation_listConversationMedia
     *
     * @param conversationId conversationId
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun conversation_list_conversation_media(conversationId: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.conversation_list_conversation_media(conversationId)
    }
    
    /**
     * DeviceMgmt.device_generatePairingCode
     *
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun device_generate_pairing_code():  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.device_generate_pairing_code()
    }
    
    /**
     * DeviceMgmt.device_confirmPairing
     *
     * @param deviceId deviceId
     * @param code code
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun device_confirm_pairing(deviceId: undefined, code: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.device_confirm_pairing(deviceId, code)
    }
    
    /**
     * DeviceMgmt.device_unpairDevice
     *
     * @param deviceId deviceId
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun device_unpair_device(deviceId: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.device_unpair_device(deviceId)
    }
    
    /**
     * DeviceMgmt.device_listPairedDevices
     *
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun device_list_paired_devices():  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.device_list_paired_devices()
    }
    
    /**
     * DeviceMgmt.device_followDevice
     *
     * @param deviceId deviceId
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun device_follow_device(deviceId: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.device_follow_device(deviceId)
    }
    
    /**
     * DeviceMgmt.device_unfollowDevice
     *
     * @param deviceId deviceId
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun device_unfollow_device(deviceId: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.device_unfollow_device(deviceId)
    }
    
    /**
     * DeviceMgmt.device_listFollowers
     *
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun device_list_followers():  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.device_list_followers()
    }
    
    /**
     * DeviceMgmt.device_isFollowing
     *
     * @param deviceId deviceId
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun device_is_following(deviceId: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.device_is_following(deviceId)
    }
    
    /**
     * MediaMgmt.media_addMediaLink
     *
     * @param url url
     * @param title title
     * @param mimeType mimeType
     * @param directory directory
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun media_add_media_link(url: undefined, title: undefined, mimeType: undefined, directory: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.media_add_media_link(url, title, mimeType, directory)
    }
    
    /**
     * MediaMgmt.media_addMediaFile
     *
     * @param filePath filePath
     * @param title title
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun media_add_media_file(filePath: undefined, title: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.media_add_media_file(filePath, title)
    }
    
    /**
     * MediaMgmt.media_getMediaByUrl
     *
     * @param url url
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun media_get_media_by_url(url: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.media_get_media_by_url(url)
    }
    
    /**
     * MediaMgmt.media_listMedia
     *
     * @param directory directory
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun media_list_media(directory: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.media_list_media(directory)
    }
    
    /**
     * MediaMgmt.media_deleteMedia
     *
     * @param pkbUrl pkbUrl
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun media_delete_media(pkbUrl: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.media_delete_media(pkbUrl)
    }
    
    /**
     * PersonMgmt.person_addPerson
     *
     * @param displayName displayName
     * @param handle handle
     * @param metadata metadata
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun person_add_person(displayName: undefined, handle: undefined, metadata: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.person_add_person(displayName, handle, metadata)
    }
    
    /**
     * PersonMgmt.person_getPersonByHandle
     *
     * @param handle handle
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun person_get_person_by_handle(handle: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.person_get_person_by_handle(handle)
    }
    
    /**
     * PersonMgmt.person_listPeople
     *
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun person_list_people():  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.person_list_people()
    }
    
    /**
     * PersonMgmt.person_updatePerson
     *
     * @param handle handle
     * @param displayName displayName
     * @param metadata metadata
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun person_update_person(handle: undefined, displayName: undefined, metadata: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.person_update_person(handle, displayName, metadata)
    }
    
    /**
     * PersonMgmt.person_deletePerson
     *
     * @param handle handle
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun person_delete_person(handle: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.person_delete_person(handle)
    }
    
    /**
     * PostMgmt.post_addPost
     *
     * @param content content
     * @param title title
     * @param tags tags
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun post_add_post(content: undefined, title: undefined, tags: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.post_add_post(content, title, tags)
    }
    
    /**
     * PostMgmt.post_getPostByUrl
     *
     * @param pkbUrl pkbUrl
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun post_get_post_by_url(pkbUrl: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.post_get_post_by_url(pkbUrl)
    }
    
    /**
     * PostMgmt.post_listPosts
     *
     * @param directory directory
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun post_list_posts(directory: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.post_list_posts(directory)
    }
    
    /**
     * PostMgmt.post_updatePost
     *
     * @param pkbUrl pkbUrl
     * @param content content
     * @param title title
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun post_update_post(pkbUrl: undefined, content: undefined, title: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.post_update_post(pkbUrl, content, title)
    }
    
    /**
     * PostMgmt.post_deletePost
     *
     * @param pkbUrl pkbUrl
     * @return 
     * @throws IllegalStateException if not connected
     * @throws RemoteException if IPC fails
     */
    @Throws(RemoteException::class)
    fun post_delete_post(pkbUrl: undefined):  {
        val s = service ?: throw IllegalStateException("Not connected to service. Call connect() first.")
        return s.post_delete_post(pkbUrl)
    }

}
