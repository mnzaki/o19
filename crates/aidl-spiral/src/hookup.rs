//! Hookup Methods for Generated Code
//!
//! Defines how generated code is integrated into consumer packages.
//! The goal: consumers don't think about it—it just works.

use crate::traits::{GeneratedArtifact, GenerationError};
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};

/// A hookup method integrates generated code into a package
pub trait HookupMethod: Send + Sync {
    /// Name of this hookup method
    fn name(&self) -> &'static str;
    
    /// Check if this method can be applied to the given package
    fn can_apply(&self, package_path: &Path) -> bool;
    
    /// Apply the hookup—integrate generated artifacts into the package
    fn apply(
        &self,
        package_path: &Path,
        artifacts: &[GeneratedArtifact],
        context: &HookupContext,
    ) -> Result<(), HookupError>;
}

/// Context for hookup operations
pub struct HookupContext {
    /// Package name
    pub package_name: String,
    
    /// Management name (e.g., "IContentMgmt")
    pub management_name: String,
    
    /// Target ring
    pub target_ring: String,
    
    /// Language
    pub language: String,
    
    /// Additional configuration
    pub config: HashMap<String, String>,
}

/// Errors during hookup
#[derive(Debug, thiserror::Error)]
pub enum HookupError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("Hookup failed: {0}")]
    Failed(String),
    
    #[error("Package not compatible: {0}")]
    Incompatible(String),
    
    #[error("Sed replacement failed: {0}")]
    SedFailed(String),
}

/// Registry of hookup methods
pub struct HookupRegistry {
    /// Registered hookup methods
    pub methods: Vec<Box<dyn HookupMethod>>,
}

impl HookupRegistry {
    pub fn new() -> Self {
        Self { methods: Vec::new() }
    }
    
    pub fn register<M: HookupMethod + 'static>(&mut self, method: M) {
        self.methods.push(Box::new(method));
    }
    
    /// Find the best hookup method for a package
    pub fn find_for(&self, package_path: &Path) -> Option<&dyn HookupMethod> {
        self.methods
            .iter()
            .find(|m| m.can_apply(package_path))
            .map(|m| m.as_ref())
    }
    
    /// Create registry with all built-in methods
    pub fn with_builtin() -> Self {
        let mut registry = Self::new();
        registry.register(RustModuleHookup);
        registry.register(RustSedHookup);
        registry.register(TypeScriptBarrelHookup);
        registry.register(JavaPackageHookup);
        registry.register(GitignoreHookup);  // Always applies
        registry
    }
}

impl Default for HookupRegistry {
    fn default() -> Self {
        Self::new()
    }
}

// ==================== Hookup Method 1: Rust Module Re-export ====================

/// For Rust crates: Re-export generated modules in lib.rs
/// 
/// Pattern: Generate to `src/generated/`, add `mod generated; pub use generated::*;` to lib.rs
pub struct RustModuleHookup;

impl HookupMethod for RustModuleHookup {
    fn name(&self) -> &'static str {
        "rust_module"
    }
    
    fn can_apply(&self, package_path: &Path) -> bool {
        package_path.join("Cargo.toml").exists()
    }
    
    fn apply(
        &self,
        package_path: &Path,
        artifacts: &[GeneratedArtifact],
        context: &HookupContext,
    ) -> Result<(), HookupError> {
        let lib_rs = package_path.join("src/lib.rs");
        
        // Ensure the spiral directory exists (as sibling to src/)
        let spiral_dir = package_path.join("spiral");
        fs::create_dir_all(&spiral_dir)?;
        
        // Write artifacts
        for artifact in artifacts {
            let path = spiral_dir.join(&artifact.path);
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent)?;
            }
            fs::write(&path, &artifact.content)?;
        }
        
        // Create or update the module file
        let mod_file = spiral_dir.join("mod.rs");
        let mod_content = generate_rust_mod_file(artifacts, context);
        fs::write(&mod_file, mod_content)?;
        
        // Check if lib.rs already has the module declaration
        if lib_rs.exists() {
            let lib_content = fs::read_to_string(&lib_rs)?;
            if !lib_content.contains("spiral") {
                // Add module declaration with path attribute at the end
                // This places spiral/ as a sibling to src/, visually separating
                // generated code from hand-written source
                let new_lib = format!(
                    "{}\n\n// Auto-generated by aidl-spiral\n#[path = \"../spiral/mod.rs\"]\npub mod spiral;\n",
                    lib_content
                );
                fs::write(&lib_rs, new_lib)?;
            }
        }
        
        Ok(())
    }
}

fn generate_rust_mod_file(artifacts: &[GeneratedArtifact], _context: &HookupContext) -> String {
    let mut content = String::from(
        "//! Auto-generated by aidl-spiral\n//!\n//! This module re-exports all generated code.\n\n"
    );
    
    // Collect all .rs files (excluding mod.rs)
    for artifact in artifacts {
        if artifact.path.ends_with(".rs") && !artifact.path.ends_with("mod.rs") {
            let module_name = artifact.path
                .trim_end_matches(".rs")
                .replace('/', "_")
                .replace('-', "_");
            
            content.push_str(&format!("pub mod {};\n", module_name));
        }
    }
    
    content
}

// ==================== Hookup Method 2: Rust Sed Replacement ====================

/// For Rust crates: Replace placeholder markers in existing files
///
/// Pattern: Add `// <aidl-spiral:gen>` in commands.rs, 
/// replace with generated content
pub struct RustSedHookup;

impl HookupMethod for RustSedHookup {
    fn name(&self) -> &'static str {
        "rust_sed"
    }
    
    fn can_apply(&self, package_path: &Path) -> bool {
        // Check for marker files
        package_path.join("Cargo.toml").exists() && 
        package_path.join("src/commands.rs").exists()
    }
    
    fn apply(
        &self,
        package_path: &Path,
        artifacts: &[GeneratedArtifact],
        context: &HookupContext,
    ) -> Result<(), HookupError> {
        let commands_rs = package_path.join("src/commands.rs");
        
        // Find the commands artifact
        let commands_artifact = artifacts
            .iter()
            .find(|a| a.path.contains("commands.rs"))
            .ok_or_else(|| HookupError::Failed("No commands.rs generated".into()))?;
        
        let content = fs::read_to_string(&commands_rs)?;
        
        // Look for marker: // <aidl-spiral:gen> ... // </aidl-spiral:gen>
        let marker_start = "// <aidl-spiral:gen>";
        let marker_end = "// </aidl-spiral:gen>";
        
        if content.contains(marker_start) && content.contains(marker_end) {
            // Replace content between markers
            let before = content.split(marker_start).next().unwrap_or("");
            let after = content.split(marker_end).nth(1).unwrap_or("");
            
            let new_content = format!(
                "{}{}\n{}\n{}{}",
                before,
                marker_start,
                commands_artifact.content,
                marker_end,
                after
            );
            
            fs::write(&commands_rs, new_content)?;
        } else {
            // No markers found—append to end
            let mut new_content = content;
            new_content.push_str("\n\n// Auto-generated by aidl-spiral\n");
            new_content.push_str(&commands_artifact.content);
            fs::write(&commands_rs, new_content)?;
        }
        
        Ok(())
    }
}

// ==================== Hookup Method 3: TypeScript Barrel ====================

/// For TypeScript packages: Create barrel exports
///
/// Pattern: Generate to `src/generated/`, re-export from `src/index.ts`
pub struct TypeScriptBarrelHookup;

impl HookupMethod for TypeScriptBarrelHookup {
    fn name(&self) -> &'static str {
        "ts_barrel"
    }
    
    fn can_apply(&self, package_path: &Path) -> bool {
        package_path.join("package.json").exists()
    }
    
    fn apply(
        &self,
        package_path: &Path,
        artifacts: &[GeneratedArtifact],
        context: &HookupContext,
    ) -> Result<(), HookupError> {
        let spiral_dir = package_path.join("spiral");
        fs::create_dir_all(&spiral_dir)?;
        
        // Write artifacts
        for artifact in artifacts {
            let path = spiral_dir.join(&artifact.path);
            if let Some(parent) = path.parent() {
                fs::create_dir_all(parent)?;
            }
            fs::write(&path, &artifact.content)?;
        }
        
        // Create barrel file
        let barrel_file = spiral_dir.join("index.ts");
        let barrel_content = generate_ts_barrel(artifacts, context);
        fs::write(&barrel_file, barrel_content)?;
        
        // Update or create main index.ts
        let index_ts = package_path.join("src/index.ts");
        if index_ts.exists() {
            let content = fs::read_to_string(&index_ts)?;
            if !content.contains("./spiral") {
                let new_content = format!(
                    "{}\n\n// Auto-generated by aidl-spiral\nexport * from './spiral';\n",
                    content
                );
                fs::write(&index_ts, new_content)?;
            }
        } else {
            fs::write(&index_ts, "export * from './spiral';\n")?;
        }
        
        Ok(())
    }
}

fn generate_ts_barrel(artifacts: &[GeneratedArtifact], _context: &HookupContext) -> String {
    let mut content = String::from(
        "// Auto-generated by aidl-spiral\n\n"
    );
    
    for artifact in artifacts {
        if artifact.path.ends_with(".ts") && !artifact.path.ends_with("index.ts") {
            let import_path = artifact.path
                .trim_end_matches(".ts")
                .replace("/index", "");
            
            content.push_str(&format!("export * from './{}';\n", import_path));
        }
    }
    
    content
}

// ==================== Hookup Method 4: Java Package ====================

/// For Java/Android: Place files in correct package structure
pub struct JavaPackageHookup;

impl HookupMethod for JavaPackageHookup {
    fn name(&self) -> &'static str {
        "java_package"
    }
    
    fn can_apply(&self, package_path: &Path) -> bool {
        package_path.join("android").exists() || 
        package_path.join("java").exists()
    }
    
    fn apply(
        &self,
        package_path: &Path,
        artifacts: &[GeneratedArtifact],
        context: &HookupContext,
    ) -> Result<(), HookupError> {
        let base_dir = if package_path.join("android").exists() {
            package_path.join("android")
        } else {
            package_path.join("java")
        };
        
        for artifact in artifacts {
            if artifact.path.starts_with("java/") {
                // Extract package path from artifact path
                let relative_path = artifact.path.trim_start_matches("java/");
                let full_path = base_dir.join(relative_path);
                
                if let Some(parent) = full_path.parent() {
                    fs::create_dir_all(parent)?;
                }
                
                fs::write(&full_path, &artifact.content)?;
            }
        }
        
        Ok(())
    }
}

// ==================== Hookup Method 5: Gitignore ====================

/// Ensures 'spiral/' is in .gitignore
///
/// This hookup always applies and ensures generated code is not committed.
pub struct GitignoreHookup;

impl HookupMethod for GitignoreHookup {
    fn name(&self) -> &'static str {
        "gitignore"
    }
    
    fn can_apply(&self, _package_path: &Path) -> bool {
        // Always apply - every package should have spiral in .gitignore
        true
    }
    
    fn apply(
        &self,
        package_path: &Path,
        _artifacts: &[GeneratedArtifact],
        _context: &HookupContext,
    ) -> Result<(), HookupError> {
        let gitignore = package_path.join(".gitignore");
        
        let entry = "# Auto-generated by aidl-spiral\nspiral/\n";
        
        if gitignore.exists() {
            let content = fs::read_to_string(&gitignore)?;
            if !content.contains("spiral/") {
                // Append to existing .gitignore
                let new_content = format!("{}\n{}", content.trim_end(), entry);
                fs::write(&gitignore, new_content)?;
            }
        } else {
            // Create new .gitignore
            fs::write(&gitignore, entry)?;
        }
        
        Ok(())
    }
}

// ==================== Auto-Detect and Apply ====================

/// Auto-detect hookup method and apply for a package
pub fn auto_hookup(
    package_path: &Path,
    artifacts: &[GeneratedArtifact],
    context: &HookupContext,
) -> Result<String, HookupError> {
    let registry = HookupRegistry::with_builtin();
    
    if let Some(method) = registry.find_for(package_path) {
        method.apply(package_path, artifacts, context)?;
        Ok(method.name().to_string())
    } else {
        Err(HookupError::Incompatible(
            format!("No hookup method found for {}", package_path.display())
        ))
    }
}
