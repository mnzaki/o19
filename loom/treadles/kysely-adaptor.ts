/**
 * KyselyAdaptorTreadle - Custom treadle for generating Kysely adaptor implementations
 *
 * Generates TypeScript Kysely adaptor implementations for foundframe-front ports.
 * Uses Prisma-generated types from foundframe-front/src/db/types.ts
 *
 * Usage in WARP.ts (future):
 *   const front = tauri.typescript.ddd()
 *     .tieup.intra(kyselyAdaptorTreadle, {
 *       entities: ['Bookmark', 'Media', 'Post', 'Person', 'Conversation'],
 *       operations: ['create', 'read', 'update', 'delete', 'list'],
 *     });
 */

import type { TreadleContext, TreadleResult } from '@o19/spire-loom/machinery/treadles';

/**
 * Configuration for KyselyAdaptorTreadle
 */
export interface KyselyAdaptorConfig {
  /** Entity names to generate adaptors for */
  entities: string[];
  /** CRUD operations to support */
  operations: ('create' | 'read' | 'update' | 'delete' | 'list')[];
  /** Path to foundframe-front package (relative to workspace root) */
  frontPackagePath?: string;
}

/**
 * Custom treadle definition for Kysely adaptor generation
 */
export const kyselyAdaptorTreadle = async (context: TreadleContext): Promise<TreadleResult> => {
  const { config, utils } = context;
  const kyselyConfig = config as KyselyAdaptorConfig;
  
  const generatedFiles: string[] = [];
  const modifiedFiles: string[] = [];
  const errors: string[] = [];
  
  const frontPath = kyselyConfig.frontPackagePath || 'packages/foundframe-front';
  const adaptorsPath = `${frontPath}/src/adaptors/gen`;
  
  // Ensure adaptors directory exists
  await utils.writeFile(`${adaptorsPath}/.gitkeep`, '');
  
  // Generate for each entity
  for (const entity of kyselyConfig.entities) {
    try {
      const entityLower = entity.toLowerCase();
      const entityPascal = entity.charAt(0).toUpperCase() + entity.slice(1);
      
      // Generate Kysely adaptor: src/adaptors/gen/{entity}.adaptor.gen.ts
      const adaptorCode = generateKyselyAdaptor(entityPascal, entityLower, kyselyConfig.operations);
      const adaptorPath = `${adaptorsPath}/${entityLower}.adaptor.gen.ts`;
      
      await utils.writeFile(adaptorPath, adaptorCode);
      generatedFiles.push(adaptorPath);
      
    } catch (e) {
      errors.push(`Failed to generate ${entity} adaptor: ${e}`);
    }
  }
  
  // Generate index file that exports all adaptors
  try {
    const indexCode = generateAdaptorIndex(kyselyConfig.entities);
    const indexPath = `${adaptorsPath}/index.gen.ts`;
    
    await utils.writeFile(indexPath, indexCode);
    generatedFiles.push(indexPath);
  } catch (e) {
    errors.push(`Failed to generate index: ${e}`);
  }
  
  // Generate factory function for creating all adaptors
  try {
    const factoryCode = generateAdaptorFactory(kyselyConfig.entities);
    const factoryPath = `${adaptorsPath}/factory.gen.ts`;
    
    await utils.writeFile(factoryPath, factoryCode);
    generatedFiles.push(factoryPath);
  } catch (e) {
    errors.push(`Failed to generate factory: ${e}`);
  }
  
  return {
    generatedFiles,
    modifiedFiles,
    errors: errors.length > 0 ? errors : undefined,
  };
};

/**
 * Generate Kysely adaptor for a single entity
 */
function generateKyselyAdaptor(
  entityPascal: string,
  entityLower: string,
  operations: string[]
): string {
  const imports = generateAdaptorImports(entityPascal, entityLower);
  const classDeclaration = generateAdaptorClass(entityPascal, entityLower, operations);
  
  return `${imports}

${classDeclaration}
`;
}

/**
 * Generate imports for the adaptor
 */
function generateAdaptorImports(entityPascal: string, entityLower: string): string {
  return `// GENERATED BY KyselyAdaptorTreadle - Do not edit

import { Kysely } from 'kysely';
import type { DB } from '../db/types.js';
import { ${entityPascal}Adaptor, type ${entityPascal}Port } from '../ports/${entityLower}.port.js';
import type {
  ${entityPascal},
  Create${entityPascal},
  Update${entityPascal},
  ${entityPascal}Filters
} from '../domain/entities/${entityLower}.js';

// Re-export for convenience
export type { ${entityPascal}Port };
`;
}

/**
 * Generate the adaptor class implementation
 */
function generateAdaptorClass(
  entityPascal: string,
  entityLower: string,
  operations: string[]
): string {
  const methods: string[] = [];
  
  if (operations.includes('create')) {
    methods.push(generateCreateMethod(entityPascal, entityLower));
  }
  
  if (operations.includes('read')) {
    methods.push(generateGetByIdMethod(entityPascal, entityLower));
    methods.push(generateGetByUrlMethod(entityPascal, entityLower));
  }
  
  if (operations.includes('list')) {
    methods.push(generateListMethod(entityPascal, entityLower));
  }
  
  if (operations.includes('update')) {
    methods.push(generateUpdateMethod(entityPascal, entityLower));
  }
  
  if (operations.includes('delete')) {
    methods.push(generateDeleteMethod(entityPascal, entityLower));
  }
  
  // Add utility methods
  methods.push(generateToDomainMethod(entityPascal, entityLower));
  methods.push(generateToDbMethod(entityPascal, entityLower));
  
  const methodCode = methods.join('\n\n');
  
  return `/**
 * Kysely implementation of ${entityPascal}Port
 * 
 * Generated adaptor that uses Kysely for type-safe SQL queries.
 */
export class Kysely${entityPascal}Adaptor extends ${entityPascal}Adaptor implements ${entityPascal}Port {
  constructor(private db: Kysely<DB>) {
    super();
  }

${indent(methodCode, 2)}
}`;
}

/**
 * Generate create method
 */
function generateCreateMethod(entityPascal: string, entityLower: string): string {
  return `async create(data: Create${entityPascal}): Promise<${entityPascal}> {
    const dbData = this.toDb(data);
    const result = await this.db
      .insertInto('${entityLower}')
      .values(dbData)
      .returningAll()
      .executeTakeFirstOrThrow();
    
    return this.toDomain(result);
  }`;
}

/**
 * Generate getById method
 */
function generateGetByIdMethod(entityPascal: string, entityLower: string): string {
  return `async getById(id: number): Promise<${entityPascal} | null> {
    const result = await this.db
      .selectFrom('${entityLower}')
      .where('id', '=', id)
      .selectAll()
      .executeTakeFirst();
    
    return result ? this.toDomain(result) : null;
  }`;
}

/**
 * Generate getByUrl method (bookmark-specific, but generic enough)
 */
function generateGetByUrlMethod(entityPascal: string, entityLower: string): string {
  // Only bookmarks have URL, but we'll generate a generic version
  // that can be customized or removed if not needed
  return `async getByUrl(url: string): Promise<${entityPascal} | null> {
    const result = await this.db
      .selectFrom('${entityLower}')
      .where('url', '=', url)
      .selectAll()
      .executeTakeFirst();
    
    return result ? this.toDomain(result) : null;
  }`;
}

/**
 * Generate list/query method
 */
function generateListMethod(entityPascal: string, entityLower: string): string {
  return `async query(filters?: ${entityPascal}Filters): Promise<${entityPascal}[]> {
    let query = this.db
      .selectFrom('${entityLower}')
      .selectAll();
    
    // Apply pagination if provided
    if (filters?.pagination?.limit) {
      query = query.limit(filters.pagination.limit);
    }
    if (filters?.pagination?.offset) {
      query = query.offset(filters.pagination.offset);
    }
    
    // Default ordering by created_at desc
    query = query.orderBy('created_at', 'desc');
    
    const results = await query.execute();
    return results.map(r => this.toDomain(r));
  }

  async searchByKeyword(keyword: string): Promise<${entityPascal}[]> {
    // Generic search - subclasses can override for entity-specific search
    const results = await this.db
      .selectFrom('${entityLower}')
      .where((eb) => eb.or([
        eb('url', 'like', \`%\${keyword}%\`),
        eb('title', 'like', \`%\${keyword}%\`),
        eb('notes', 'like', \`%\${keyword}%\`)
      ]))
      .selectAll()
      .execute();
    
    return results.map(r => this.toDomain(r));
  }`;
}

/**
 * Generate update method
 */
function generateUpdateMethod(entityPascal: string, entityLower: string): string {
  return `async update(id: number, data: Update${entityPascal}): Promise<void> {
    const dbData = this.toDb(data);
    
    await this.db
      .updateTable('${entityLower}')
      .set(dbData)
      .where('id', '=', id)
      .execute();
  }`;
}

/**
 * Generate delete method
 */
function generateDeleteMethod(entityPascal: string, entityLower: string): string {
  return `async delete(id: number): Promise<void> {
    await this.db
      .deleteFrom('${entityLower}')
      .where('id', '=', id)
      .execute();
  }`;
}

/**
 * Generate toDomain mapper method
 */
function generateToDomainMethod(entityPascal: string, entityLower: string): string {
  return `/**
   * Map database row to domain entity
   */
  private toDomain(row: any): ${entityPascal} {
    // TODO: Customize mapping based on entity structure
    return {
      id: row.id,
      ...row,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    } as ${entityPascal};
  }`;
}

/**
 * Generate toDb mapper method
 */
function generateToDbMethod(entityPascal: string, entityLower: string): string {
  return `/**
   * Map domain entity to database row
   */
  private toDb(data: Partial<${entityPascal}>): Record<string, any> {
    const dbData: Record<string, any> = {};
    
    // Map camelCase to snake_case
    for (const [key, value] of Object.entries(data)) {
      if (value !== undefined) {
        const snakeKey = key.replace(/[A-Z]/g, letter => \`_\${letter.toLowerCase()}\`);
        dbData[snakeKey] = value;
      }
    }
    
    return dbData;
  }`;
}

/**
 * Generate index file exporting all adaptors
 */
function generateAdaptorIndex(entities: string[]): string {
  const exports = entities.map(e => {
    const lower = e.toLowerCase();
    const pascal = e.charAt(0).toUpperCase() + e.slice(1);
    return `export { Kysely${pascal}Adaptor } from './${lower}.adaptor.gen.js';`;
  }).join('\n');
  
  return `// GENERATED BY KyselyAdaptorTreadle - Do not edit
// Export all Kysely adaptor implementations

${exports}
`;
}

/**
 * Generate factory function for creating all adaptors
 */
function generateAdaptorFactory(entities: string[]): string {
  const imports = entities.map(e => {
    const lower = e.toLowerCase();
    const pascal = e.charAt(0).toUpperCase() + e.slice(1);
    return `import { Kysely${pascal}Adaptor } from './${lower}.adaptor.gen.js';`;
  }).join('\n');
  
  const portTypes = entities.map(e => {
    const pascal = e.charAt(0).toUpperCase() + e.slice(1);
    return `  ${pascal.toLowerCase()}: ${pascal}Port;`;
  }).join('\n');
  
  const adaptorCreates = entities.map(e => {
    const lower = e.toLowerCase();
    const pascal = e.charAt(0).toUpperCase() + e.slice(1);
    return `    ${lower}: new Kysely${pascal}Adaptor(db),`;
  }).join('\n');
  
  return `// GENERATED BY KyselyAdaptorTreadle - Do not edit
// Factory function for creating all Kysely adaptors

import { Kysely } from 'kysely';
import type { DB } from '../db/types.js';
${imports}

// Import port types
import type {
${entities.map(e => `  ${e.charAt(0).toUpperCase() + e.slice(1)}Port,`).join('\n')}
} from '../ports/index.js';

/**
 * All database ports interface
 */
export interface DatabasePorts {
${portTypes}
}

/**
 * Create all Kysely adaptors with the given database instance
 * 
 * @example
 * \`\`\`typescript
 * import { Kysely } from 'kysely';
 * import { createKyselyAdaptors } from './adaptors/gen/factory.gen.js';
 * 
 * const db = new Kysely<DB>({
 *   dialect: new SQLiteDialect({ database: new SQLiteDb('app.db') })
 * });
 * 
 * const adaptors = createKyselyAdaptors(db);
 * 
 * // Use adaptors
 * const bookmark = await adaptors.bookmark.getById(1);
 * \`\`\`
 */
export function createKyselyAdaptors(db: Kysely<DB>): DatabasePorts {
  return {
${adaptorCreates}
  };
}

/**
 * Convenience export for single adaptor creation
 */
export {
${entities.map(e => `  Kysely${e.charAt(0).toUpperCase() + e.slice(1)}Adaptor,`).join('\n')}
};
`;
}

/**
 * Helper to indent code
 */
function indent(code: string, spaces: number): string {
  const indentStr = ' '.repeat(spaces);
  return code.split('\n').map(line => line ? indentStr + line : line).join('\n');
}

// Type export for use in WARP.ts
export type { KyselyAdaptorConfig };
