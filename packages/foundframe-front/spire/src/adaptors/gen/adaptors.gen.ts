// GENERATED BY SPIRE-LOOM - DO NOT EDIT (even if LLM)
// 
// This file is automatically generated from a template.
// Changes will be overwritten on next generation.
// 
// Template: node_modules/@o19/spire-loom/machinery/bobbin/kysely/adaptors.ts.ejs
// Template file: adaptors.ts.ejs
// To override: Copy this template to loom/bobbin/kysely/adaptors.ts.ejs
// 
// To modify the generated output, edit the template file above.
// GENERATED BY kysely-adaptor Treadle - Do not edit

import { Kysely } from 'kysely';
import type { DB } from '../db/types.js';
import { BookmarkAdaptor, type BookmarkPort } from '../ports/bookmark.port.js';
import type {
  Bookmark,
  CreateBookmark,
  UpdateBookmark,
  BookmarkFilters
} from '../domain/entities/bookmark.js';
import { MediaAdaptor, type MediaPort } from '../ports/media.port.js';
import type {
  Media,
  CreateMedia,
  UpdateMedia,
  MediaFilters
} from '../domain/entities/media.js';
import { PostAdaptor, type PostPort } from '../ports/post.port.js';
import type {
  Post,
  CreatePost,
  UpdatePost,
  PostFilters
} from '../domain/entities/post.js';
import { PersonAdaptor, type PersonPort } from '../ports/person.port.js';
import type {
  Person,
  CreatePerson,
  UpdatePerson,
  PersonFilters
} from '../domain/entities/person.js';
import { ConversationAdaptor, type ConversationPort } from '../ports/conversation.port.js';
import type {
  Conversation,
  CreateConversation,
  UpdateConversation,
  ConversationFilters
} from '../domain/entities/conversation.js';

// Re-export for convenience
export type { BookmarkPort };
export type { MediaPort };
export type { PostPort };
export type { PersonPort };
export type { ConversationPort };

/**
 * Kysely implementation of BookmarkPort
 *
 * Generated adaptor that uses Kysely for type-safe SQL queries.
 */
export class KyselyBookmarkAdaptor extends BookmarkAdaptor implements BookmarkPort {
  constructor(private db: Kysely<DB>) {
    super();
  }

  async getById(id: number): Promise<Bookmark | null> {
    const result = await this.db
      .selectFrom('bookmark')
      .where('id', '=', id)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async getByUrl(url: string): Promise<Bookmark | null> {
    const result = await this.db
      .selectFrom('bookmark')
      .where('url', '=', url)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async query(filters?: BookmarkFilters): Promise<Bookmark[]> {
    let query = this.db
      .selectFrom('bookmark')
      .selectAll();

    // Apply pagination if provided
    if (filters?.pagination?.limit) {
      query = query.limit(filters.pagination.limit);
    }
    if (filters?.pagination?.offset) {
      query = query.offset(filters.pagination.offset);
    }

    // Default ordering by created_at desc
    query = query.orderBy('created_at', 'desc');

    const results = await query.execute();
    return results.map(r => this.toDomain(r));
  }

  async searchByKeyword(keyword: string): Promise<Bookmark[]> {
    // Generic search - subclasses can override for entity-specific search
    const results = await this.db
      .selectFrom('bookmark')
      .where((eb) => eb.or([
        eb('url', 'like', `%${keyword}%`),
        eb('title', 'like', `%${keyword}%`),
        eb('notes', 'like', `%${keyword}%`)
      ]))
      .selectAll()
      .execute();

    return results.map(r => this.toDomain(r));
  }

  /**
   * Map database row to domain entity
   */
  private toDomain(row: any): Bookmark {
    // TODO: Customize mapping based on entity structure
    return {
      id: row.id,
      ...row,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    } as Bookmark;
  }

  /**
   * Map domain entity to database row
   */
  private toDb(data: Partial<Bookmark>): Record<string, any> {
    const dbData: Record<string, any> = {};

    // Map camelCase to snake_case
    for (const [key, value] of Object.entries(data)) {
      if (value !== undefined) {
        const snakeKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
        dbData[snakeKey] = value;
      }
    }

    return dbData;
  }
}

/**
 * Kysely implementation of MediaPort
 *
 * Generated adaptor that uses Kysely for type-safe SQL queries.
 */
export class KyselyMediaAdaptor extends MediaAdaptor implements MediaPort {
  constructor(private db: Kysely<DB>) {
    super();
  }

  async getById(id: number): Promise<Media | null> {
    const result = await this.db
      .selectFrom('media')
      .where('id', '=', id)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async getByUrl(url: string): Promise<Media | null> {
    const result = await this.db
      .selectFrom('media')
      .where('url', '=', url)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async query(filters?: MediaFilters): Promise<Media[]> {
    let query = this.db
      .selectFrom('media')
      .selectAll();

    // Apply pagination if provided
    if (filters?.pagination?.limit) {
      query = query.limit(filters.pagination.limit);
    }
    if (filters?.pagination?.offset) {
      query = query.offset(filters.pagination.offset);
    }

    // Default ordering by created_at desc
    query = query.orderBy('created_at', 'desc');

    const results = await query.execute();
    return results.map(r => this.toDomain(r));
  }

  async searchByKeyword(keyword: string): Promise<Media[]> {
    // Generic search - subclasses can override for entity-specific search
    const results = await this.db
      .selectFrom('media')
      .where((eb) => eb.or([
        eb('url', 'like', `%${keyword}%`),
        eb('title', 'like', `%${keyword}%`),
        eb('notes', 'like', `%${keyword}%`)
      ]))
      .selectAll()
      .execute();

    return results.map(r => this.toDomain(r));
  }

  /**
   * Map database row to domain entity
   */
  private toDomain(row: any): Media {
    // TODO: Customize mapping based on entity structure
    return {
      id: row.id,
      ...row,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    } as Media;
  }

  /**
   * Map domain entity to database row
   */
  private toDb(data: Partial<Media>): Record<string, any> {
    const dbData: Record<string, any> = {};

    // Map camelCase to snake_case
    for (const [key, value] of Object.entries(data)) {
      if (value !== undefined) {
        const snakeKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
        dbData[snakeKey] = value;
      }
    }

    return dbData;
  }
}

/**
 * Kysely implementation of PostPort
 *
 * Generated adaptor that uses Kysely for type-safe SQL queries.
 */
export class KyselyPostAdaptor extends PostAdaptor implements PostPort {
  constructor(private db: Kysely<DB>) {
    super();
  }

  async getById(id: number): Promise<Post | null> {
    const result = await this.db
      .selectFrom('post')
      .where('id', '=', id)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async getByUrl(url: string): Promise<Post | null> {
    const result = await this.db
      .selectFrom('post')
      .where('url', '=', url)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async query(filters?: PostFilters): Promise<Post[]> {
    let query = this.db
      .selectFrom('post')
      .selectAll();

    // Apply pagination if provided
    if (filters?.pagination?.limit) {
      query = query.limit(filters.pagination.limit);
    }
    if (filters?.pagination?.offset) {
      query = query.offset(filters.pagination.offset);
    }

    // Default ordering by created_at desc
    query = query.orderBy('created_at', 'desc');

    const results = await query.execute();
    return results.map(r => this.toDomain(r));
  }

  async searchByKeyword(keyword: string): Promise<Post[]> {
    // Generic search - subclasses can override for entity-specific search
    const results = await this.db
      .selectFrom('post')
      .where((eb) => eb.or([
        eb('url', 'like', `%${keyword}%`),
        eb('title', 'like', `%${keyword}%`),
        eb('notes', 'like', `%${keyword}%`)
      ]))
      .selectAll()
      .execute();

    return results.map(r => this.toDomain(r));
  }

  /**
   * Map database row to domain entity
   */
  private toDomain(row: any): Post {
    // TODO: Customize mapping based on entity structure
    return {
      id: row.id,
      ...row,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    } as Post;
  }

  /**
   * Map domain entity to database row
   */
  private toDb(data: Partial<Post>): Record<string, any> {
    const dbData: Record<string, any> = {};

    // Map camelCase to snake_case
    for (const [key, value] of Object.entries(data)) {
      if (value !== undefined) {
        const snakeKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
        dbData[snakeKey] = value;
      }
    }

    return dbData;
  }
}

/**
 * Kysely implementation of PersonPort
 *
 * Generated adaptor that uses Kysely for type-safe SQL queries.
 */
export class KyselyPersonAdaptor extends PersonAdaptor implements PersonPort {
  constructor(private db: Kysely<DB>) {
    super();
  }

  async getById(id: number): Promise<Person | null> {
    const result = await this.db
      .selectFrom('person')
      .where('id', '=', id)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async getByUrl(url: string): Promise<Person | null> {
    const result = await this.db
      .selectFrom('person')
      .where('url', '=', url)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async query(filters?: PersonFilters): Promise<Person[]> {
    let query = this.db
      .selectFrom('person')
      .selectAll();

    // Apply pagination if provided
    if (filters?.pagination?.limit) {
      query = query.limit(filters.pagination.limit);
    }
    if (filters?.pagination?.offset) {
      query = query.offset(filters.pagination.offset);
    }

    // Default ordering by created_at desc
    query = query.orderBy('created_at', 'desc');

    const results = await query.execute();
    return results.map(r => this.toDomain(r));
  }

  async searchByKeyword(keyword: string): Promise<Person[]> {
    // Generic search - subclasses can override for entity-specific search
    const results = await this.db
      .selectFrom('person')
      .where((eb) => eb.or([
        eb('url', 'like', `%${keyword}%`),
        eb('title', 'like', `%${keyword}%`),
        eb('notes', 'like', `%${keyword}%`)
      ]))
      .selectAll()
      .execute();

    return results.map(r => this.toDomain(r));
  }

  /**
   * Map database row to domain entity
   */
  private toDomain(row: any): Person {
    // TODO: Customize mapping based on entity structure
    return {
      id: row.id,
      ...row,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    } as Person;
  }

  /**
   * Map domain entity to database row
   */
  private toDb(data: Partial<Person>): Record<string, any> {
    const dbData: Record<string, any> = {};

    // Map camelCase to snake_case
    for (const [key, value] of Object.entries(data)) {
      if (value !== undefined) {
        const snakeKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
        dbData[snakeKey] = value;
      }
    }

    return dbData;
  }
}

/**
 * Kysely implementation of ConversationPort
 *
 * Generated adaptor that uses Kysely for type-safe SQL queries.
 */
export class KyselyConversationAdaptor extends ConversationAdaptor implements ConversationPort {
  constructor(private db: Kysely<DB>) {
    super();
  }

  async getById(id: number): Promise<Conversation | null> {
    const result = await this.db
      .selectFrom('conversation')
      .where('id', '=', id)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async getByUrl(url: string): Promise<Conversation | null> {
    const result = await this.db
      .selectFrom('conversation')
      .where('url', '=', url)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async query(filters?: ConversationFilters): Promise<Conversation[]> {
    let query = this.db
      .selectFrom('conversation')
      .selectAll();

    // Apply pagination if provided
    if (filters?.pagination?.limit) {
      query = query.limit(filters.pagination.limit);
    }
    if (filters?.pagination?.offset) {
      query = query.offset(filters.pagination.offset);
    }

    // Default ordering by created_at desc
    query = query.orderBy('created_at', 'desc');

    const results = await query.execute();
    return results.map(r => this.toDomain(r));
  }

  async searchByKeyword(keyword: string): Promise<Conversation[]> {
    // Generic search - subclasses can override for entity-specific search
    const results = await this.db
      .selectFrom('conversation')
      .where((eb) => eb.or([
        eb('url', 'like', `%${keyword}%`),
        eb('title', 'like', `%${keyword}%`),
        eb('notes', 'like', `%${keyword}%`)
      ]))
      .selectAll()
      .execute();

    return results.map(r => this.toDomain(r));
  }

  /**
   * Map database row to domain entity
   */
  private toDomain(row: any): Conversation {
    // TODO: Customize mapping based on entity structure
    return {
      id: row.id,
      ...row,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    } as Conversation;
  }

  /**
   * Map domain entity to database row
   */
  private toDb(data: Partial<Conversation>): Record<string, any> {
    const dbData: Record<string, any> = {};

    // Map camelCase to snake_case
    for (const [key, value] of Object.entries(data)) {
      if (value !== undefined) {
        const snakeKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
        dbData[snakeKey] = value;
      }
    }

    return dbData;
  }
}

