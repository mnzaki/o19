// GENERATED BY SPIRE-LOOM - DO NOT EDIT (even if LLM)
// 
// This file is automatically generated from a template.
// Changes will be overwritten on next generation.
// 
// Template: kysely/adaptor.ts.ejs
// Template file: adaptor.ts.ejs
// This is a custom template in your workspace
// 
// To modify the generated output, edit the template file above.
// GENERATED BY kysely-adaptor Treadle - Do not edit

import { Kysely } from 'kysely';
import type { DB } from '../db/types.js';
import { ConversationAdaptor, type ConversationPort } from '../ports/conversation.port.js';
import type {
  Conversation,
  CreateConversation,
  UpdateConversation,
  ConversationFilters
} from '../domain/entities/conversation.js';

// Re-export for convenience
export type { ConversationPort };

/**
 * Kysely implementation of ConversationPort
 *
 * Generated adaptor that uses Kysely for type-safe SQL queries.
 */
export class KyselyConversationAdaptor extends ConversationAdaptor implements ConversationPort {
  constructor(private db: Kysely<DB>) {
    super();
  }

  async getById(id: number): Promise<Conversation | null> {
    const result = await this.db
      .selectFrom('conversation')
      .where('id', '=', id)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async getByUrl(url: string): Promise<Conversation | null> {
    const result = await this.db
      .selectFrom('conversation')
      .where('url', '=', url)
      .selectAll()
      .executeTakeFirst();

    return result ? this.toDomain(result) : null;
  }

  async query(filters?: ConversationFilters): Promise<Conversation[]> {
    let query = this.db
      .selectFrom('conversation')
      .selectAll();

    // Apply pagination if provided
    if (filters?.pagination?.limit) {
      query = query.limit(filters.pagination.limit);
    }
    if (filters?.pagination?.offset) {
      query = query.offset(filters.pagination.offset);
    }

    // Default ordering by created_at desc
    query = query.orderBy('created_at', 'desc');

    const results = await query.execute();
    return results.map(r => this.toDomain(r));
  }

  async searchByKeyword(keyword: string): Promise<Conversation[]> {
    // Generic search - subclasses can override for entity-specific search
    const results = await this.db
      .selectFrom('conversation')
      .where((eb) => eb.or([
        eb('url', 'like', `%${keyword}%`),
        eb('title', 'like', `%${keyword}%`),
        eb('notes', 'like', `%${keyword}%`)
      ]))
      .selectAll()
      .execute();

    return results.map(r => this.toDomain(r));
  }

  /**
   * Map database row to domain entity
   */
  private toDomain(row: any): Conversation {
    // TODO: Customize mapping based on entity structure
    return {
      id: row.id,
      ...row,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    } as Conversation;
  }

  /**
   * Map domain entity to database row
   */
  private toDb(data: Partial<Conversation>): Record<string, any> {
    const dbData: Record<string, any> = {};

    // Map camelCase to snake_case
    for (const [key, value] of Object.entries(data)) {
      if (value !== undefined) {
        const snakeKey = key.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
        dbData[snakeKey] = value;
      }
    }

    return dbData;
  }
}
