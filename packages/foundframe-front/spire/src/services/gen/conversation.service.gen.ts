// GENERATED BY SPIRE-LOOM - DO NOT EDIT (even if LLM)
// 
// This file is automatically generated from a template.
// Changes will be overwritten on next generation.
// 
// Template: node_modules/@o19/spire-loom/machinery/bobbin/ddd/service.ts.ejs
// Template file: service.ts.ejs
// To override: Copy this template to loom/bobbin/ddd/service.ts.ejs
// 
// To modify the generated output, edit the template file above.
/**
 * ConversationService
 * 
 * Domain service for Conversation operations.
 * Routes read operations to readAdaptor, write operations to writeAdaptor.
 * 
 * @generated by ddd-services treadle
 */

import type {
  ConversationPort,
  ConversationReadAdaptor,
  ConversationWriteAdaptor
} from '../../ports/gen/conversation.port.gen.js';

export class ConversationService implements ConversationPort {
  constructor(
    private readAdaptor: ConversationReadAdaptor,
    private writeAdaptor: ConversationWriteAdaptor
  ) {}

  // ============================================================================
  // Read Operations (via Kysely)
  // ============================================================================

  async getConversation(
    conversationId: string,
  ): Promise<Conversation> {
    return this.readAdaptor.getConversation(
      conversationId,
    );
  }

  async listConversations(
  ): Promise<string[][]> {
    return this.readAdaptor.listConversations(
    );
  }

  // ============================================================================
  // Write Operations (via Tauri)
  // ============================================================================

  async addConversation(
    conversationId: string,
    title?: string,
    participants?: string[],
  ): Promise<void> {
    return this.writeAdaptor.addConversation(
      conversationId,
      title,
      participants,
    );
  }

  async updateConversation(
    conversationId: string,
    title?: string,
    participants?: string[],
  ): Promise<boolean> {
    return this.writeAdaptor.updateConversation(
      conversationId,
      title,
      participants,
    );
  }

  async deleteConversation(
    conversationId: string,
  ): Promise<boolean> {
    return this.writeAdaptor.deleteConversation(
      conversationId,
    );
  }

  // ============================================================================
  // Passthrough Operations (implementation-specific)
  // ============================================================================

  async addParticipant(
    conversationId: string,
    personHandle: string,
    role?: string,
  ): Promise<boolean> {
    // Passthrough method - implement based on domain logic
    throw new Error('add_participant not implemented');
  }

  async removeParticipant(
    conversationId: string,
    personHandle: string,
  ): Promise<boolean> {
    // Passthrough method - implement based on domain logic
    throw new Error('remove_participant not implemented');
  }

  async listParticipants(
    conversationId: string,
  ): Promise<string[][]> {
    // Passthrough method - implement based on domain logic
    throw new Error('list_participants not implemented');
  }

  async addConversationMedia(
    conversationId: string,
    mediaUrl: string,
    context?: Record&lt;string,
  ): Promise<boolean> {
    // Passthrough method - implement based on domain logic
    throw new Error('add_conversation_media not implemented');
  }

  async removeConversationMedia(
    conversationId: string,
    mediaUrl: string,
  ): Promise<boolean> {
    // Passthrough method - implement based on domain logic
    throw new Error('remove_conversation_media not implemented');
  }

  async listConversationMedia(
    conversationId: string,
  ): Promise<string[][]> {
    // Passthrough method - implement based on domain logic
    throw new Error('list_conversation_media not implemented');
  }
}
