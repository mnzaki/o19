/**
 * Configuration File Tools
 *
 * Tools for manipulating configuration files (Tauri permissions, etc.)
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import { ensureDir, readJson, writeJson, fileContains } from './file-system-operations.js';

// ============================================================================
// Tauri Configuration
// ============================================================================

export interface TauriPermission {
  identifier: string;
  description?: string;
  commands?: {
    allow?: string[];
    deny?: string[];
  };
}

/**
 * Ensure a Tauri permissions file exists with given permissions.
 */
export function ensureTauriPermissions(
  cratePath: string,
  permissions: TauriPermission[]
): void {
  const permissionsDir = path.join(cratePath, 'permissions');
  ensureDir(permissionsDir);
  
  const defaultTomlPath = path.join(permissionsDir, 'default.toml');
  
  // Build TOML content
  const lines: string[] = [
    '# Auto-generated by spire-loom',
    '# Do not edit manually - will be overwritten',
    '',
  ];
  
  for (const perm of permissions) {
    lines.push('[[permission]]');
    lines.push(`identifier = "${perm.identifier}"`);
    if (perm.description) {
      lines.push(`description = "${perm.description}"`);
    }
    if (perm.commands?.allow) {
      lines.push('commands.allow = [');
      for (const cmd of perm.commands.allow) {
        lines.push(`  "${cmd}",`);
      }
      lines.push(']');
    }
    if (perm.commands?.deny) {
      lines.push('commands.deny = [');
      for (const cmd of perm.commands.deny) {
        lines.push(`  "${cmd}",`);
      }
      lines.push(']');
    }
    lines.push('');
  }
  
  fs.writeFileSync(defaultTomlPath, lines.join('\n'), 'utf-8');
}

/**
 * Ensure Tauri capabilities file includes our plugin.
 */
export function ensureTauriCapability(
  appPath: string,
  pluginIdentifier: string,
  permissions: string[]
): boolean {
  const capabilitiesDir = path.join(appPath, 'src-tauri', 'capabilities');
  ensureDir(capabilitiesDir);
  
  const defaultJsonPath = path.join(capabilitiesDir, 'default.json');
  const capability = readJson<{
    identifier?: string;
    windows?: string[];
    permissions?: string[];
  }>(defaultJsonPath, {
    identifier: 'default',
    windows: ['main'],
    permissions: [],
  });
  
  // Add plugin permissions
  const pluginPerms = permissions.map(p => `${pluginIdentifier}:${p}`);
  const existingPerms = new Set(capability.permissions ?? []);
  let changed = false;
  
  for (const perm of pluginPerms) {
    if (!existingPerms.has(perm)) {
      existingPerms.add(perm);
      changed = true;
    }
  }
  
  if (changed) {
    capability.permissions = Array.from(existingPerms);
    writeJson(defaultJsonPath, capability, 2);
  }
  
  return changed;
}

// ============================================================================
// Rust Module Registration
// ============================================================================

/**
 * Ensure a module is declared in lib.rs or main.rs.
 */
export function ensureRustModDeclared(
  cratePath: string,
  modName: string,
  options: { pub?: boolean; cfg?: string } = {}
): boolean {
  const srcDir = path.join(cratePath, 'src');
  
  // Find entry file
  let entryFile = 'lib.rs';
  if (!fs.existsSync(path.join(srcDir, entryFile))) {
    entryFile = 'main.rs';
  }
  
  const entryPath = path.join(srcDir, entryFile);
  if (!fs.existsSync(entryPath)) {
    throw new Error(`No entry file found in ${srcDir}`);
  }
  
  const content = fs.readFileSync(entryPath, 'utf-8');
  
  // Build mod declaration
  let modDecl = options.pub ? `pub mod ${modName};` : `mod ${modName};`;
  if (options.cfg) {
    modDecl = `#[cfg(${options.cfg})]\n${modDecl}`;
  }
  
  // Check if already present
  const modRegex = new RegExp(`^\\s*(#\[cfg\([^)]+\)\]\\s*)?\\s*(pub\\s+)?mod\\s+${modName};`, 'm');
  if (modRegex.test(content)) {
    return false;
  }
  
  // Add to end of file
  fs.writeFileSync(entryPath, content + '\n' + modDecl + '\n', 'utf-8');
  return true;
}

/**
 * Ensure a use statement is present.
 */
export function ensureRustUseAdded(
  filePath: string,
  usePath: string,
  options: { pub?: boolean; as?: string } = {}
): boolean {
  if (!fs.existsSync(filePath)) {
    throw new Error(`File not found: ${filePath}`);
  }
  
  const content = fs.readFileSync(filePath, 'utf-8');
  
  // Build use statement
  let useStmt = options.pub ? `pub use ${usePath}` : `use ${usePath}`;
  if (options.as) {
    useStmt += ` as ${options.as}`;
  }
  useStmt += ';';
  
  // Check if already present
  const useRegex = new RegExp(`^\\s*use\\s+${usePath.replace(/\./g, '\\.')}\\s*;`, 'm');
  if (useRegex.test(content)) {
    return false;
  }
  
  // Add after other use statements or at top
  const lines = content.split('\n');
  let lastUseIndex = -1;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].trim().startsWith('use ')) {
      lastUseIndex = i;
    }
  }
  
  if (lastUseIndex >= 0) {
    lines.splice(lastUseIndex + 1, 0, useStmt);
  } else {
    // Add after module comments
    let insertIndex = 0;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].startsWith('//!') || lines[i].startsWith('//') || lines[i].trim() === '') {
        insertIndex = i + 1;
      } else {
        break;
      }
    }
    lines.splice(insertIndex, 0, useStmt);
  }
  
  fs.writeFileSync(filePath, lines.join('\n'), 'utf-8');
  return true;
}

// ============================================================================
// TypeScript Export Registration
// ============================================================================

/**
 * Ensure an export is present in index.ts.
 */
export function ensureTsExportAdded(
  indexPath: string,
  exportPath: string,
  options: { named?: string; type?: boolean } = {}
): boolean {
  ensureDir(path.dirname(indexPath));
  
  let content = '';
  if (fs.existsSync(indexPath)) {
    content = fs.readFileSync(indexPath, 'utf-8');
  }
  
  // Build export statement
  let exportStmt: string;
  if (options.named) {
    if (options.type) {
      exportStmt = `export type { ${options.named} } from '${exportPath}';`;
    } else {
      exportStmt = `export { ${options.named} } from '${exportPath}';`;
    }
  } else {
    exportStmt = `export * from '${exportPath}';`;
  }
  
  // Check if already present
  if (content.includes(exportStmt)) {
    return false;
  }
  
  // Add to end
  fs.writeFileSync(indexPath, content + exportStmt + '\n', 'utf-8');
  return true;
}

// ============================================================================
// Build Script Integration
// ============================================================================

/**
 * Ensure a build.rs file exists with given content.
 */
export function ensureBuildRs(
  cratePath: string,
  content: string
): boolean {
  const buildRsPath = path.join(cratePath, 'build.rs');
  
  const preamble = `// Auto-generated by spire-loom
// Do not edit manually - will be overwritten

`;
  
  const fullContent = preamble + content;
  
  if (fs.existsSync(buildRsPath)) {
    const existing = fs.readFileSync(buildRsPath, 'utf-8');
    if (existing === fullContent) {
      return false;
    }
  }
  
  fs.writeFileSync(buildRsPath, fullContent, 'utf-8');
  return true;
}

/**
 * Add a build dependency to Cargo.toml.
 */
export function ensureBuildDependency(
  cratePath: string,
  name: string,
  version = '*'
): boolean {
  const cargoTomlPath = path.join(cratePath, 'Cargo.toml');
  if (!fs.existsSync(cargoTomlPath)) {
    throw new Error(`No Cargo.toml at ${cratePath}`);
  }
  
  const content = fs.readFileSync(cargoTomlPath, 'utf-8');
  
  // Check for [build-dependencies] section
  const hasBuildDeps = /\[build-dependencies\]/.test(content);
  const depRegex = new RegExp(`^${name}\\s*=`, 'm');
  
  if (depRegex.test(content)) {
    return false; // Already present somewhere
  }
  
  const depLine = `${name} = "${version}"`;
  
  if (hasBuildDeps) {
    // Add to existing section
    const newContent = content.replace(
      /(\[build-dependencies\]\n)/,
      `$1${depLine}\n`
    );
    fs.writeFileSync(cargoTomlPath, newContent, 'utf-8');
  } else {
    // Add new section
    fs.writeFileSync(cargoTomlPath, content + `\n[build-dependencies]\n${depLine}\n`, 'utf-8');
  }
  
  return true;
}

// ============================================================================
// Android Manifest
// ============================================================================

/**
 * Ensure AndroidManifest.xml contains a service declaration.
 */
export function ensureAndroidServiceDeclared(
  manifestPath: string,
  serviceClass: string,
  options: {
    exported?: boolean;
    enabled?: boolean;
    foregroundServiceType?: string;
  } = {}
): boolean {
  if (!fs.existsSync(manifestPath)) {
    // Create basic manifest
    const manifest = `<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application>
    </application>
</manifest>`;
    ensureDir(path.dirname(manifestPath));
    fs.writeFileSync(manifestPath, manifest, 'utf-8');
  }
  
  const content = fs.readFileSync(manifestPath, 'utf-8');
  
  // Check if service already declared
  const serviceRegex = new RegExp(`<service[^>]*android:name="${serviceClass}"`);
  if (serviceRegex.test(content)) {
    return false;
  }
  
  // Build service element
  const attrs: string[] = [`android:name="${serviceClass}"`];
  if (options.exported !== undefined) attrs.push(`android:exported="${options.exported}"`);
  if (options.enabled !== undefined) attrs.push(`android:enabled="${options.enabled}"`);
  if (options.foregroundServiceType) {
    attrs.push(`android:foregroundServiceType="${options.foregroundServiceType}"`);
  }
  
  const serviceElement = `        <service ${attrs.join(' ')} />`;
  
  // Insert before </application>
  const newContent = content.replace(
    /(\s*<\/application>)/,
    `\n${serviceElement}$1`
  );
  
  fs.writeFileSync(manifestPath, newContent, 'utf-8');
  return true;
}
