/**
 * File System Tools
 *
 * Low-level file operations used by the code generator.
 * All operations are idempotent (safe to run multiple times).
 */

import * as fs from 'node:fs';
import * as path from 'node:path';

/**
 * Ensure a directory exists (create if not present).
 */
export function ensureDir(dirPath: string): void {
  fs.mkdirSync(dirPath, { recursive: true });
}

/**
 * Ensure a file exists with given content (create or update).
 * Returns true if file was created, false if already existed with same content.
 */
export function ensureFile(filePath: string, content: string): boolean {
  ensureDir(path.dirname(filePath));
  
  if (fs.existsSync(filePath)) {
    const existing = fs.readFileSync(filePath, 'utf-8');
    if (existing === content) return false;
  }
  
  fs.writeFileSync(filePath, content, 'utf-8');
  return true;
}

/**
 * Options for text block insertion
 */
export interface InsertTextOptions {
  /** Marker comment to identify the block (e.g., '// GENERATED BY SPIRE-LOOM') */
  marker: string;
  /** Where to insert: 'start', 'end', or 'after' a specific pattern */
  position: 'start' | 'end' | 'after';
  /** Pattern to find when position is 'after' */
  after?: string;
  /** If true, don't add the marker comments around the block */
  noMarkers?: boolean;
}

/**
 * Ensure a text block is present in a file (idempotent insertion).
 * The block is identified by a marker and can be replaced if content changes.
 */
export function ensureTextBlockInserted(
  filePath: string,
  blockContent: string,
  options: InsertTextOptions
): boolean {
  ensureDir(path.dirname(filePath));
  
  let content = '';
  if (fs.existsSync(filePath)) {
    content = fs.readFileSync(filePath, 'utf-8');
  }
  
  const startMarker = options.noMarkers ? '' : `\n${options.marker} >>\n`;
  const endMarker = options.noMarkers ? '' : `\n${options.marker} <<\n`;
  const fullBlock = startMarker + blockContent + endMarker;
  
  // Check if block already exists with same content
  const escapedMarker = options.marker.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const blockRegex = new RegExp(
    `${escapedMarker} >>\\\\n([\\\\s\\\\S]*?)\\\\n${escapedMarker} <<`,
    'g'
  );
  
  const existingMatch = blockRegex.exec(content);
  if (existingMatch) {
    const existingContent = existingMatch[1];
    if (existingContent === blockContent) {
      return false; // Already present with same content
    }
    // Replace existing block
    const newContent = content.replace(blockRegex, fullBlock);
    fs.writeFileSync(filePath, newContent, 'utf-8');
    return true;
  }
  
  // Insert new block
  let newContent: string;
  switch (options.position) {
    case 'start':
      newContent = fullBlock + content;
      break;
    case 'end':
      newContent = content + fullBlock;
      break;
    case 'after':
      if (!options.after) {
        throw new Error("'after' pattern required when position is 'after'");
      }
      const afterIndex = content.indexOf(options.after);
      if (afterIndex === -1) {
        throw new Error(`Pattern not found: ${options.after}`);
      }
      const insertIndex = afterIndex + options.after.length;
      newContent = content.slice(0, insertIndex) + fullBlock + content.slice(insertIndex);
      break;
  }
  
  fs.writeFileSync(filePath, newContent, 'utf-8');
  return true;
}

/**
 * Remove a text block identified by marker (idempotent).
 */
export function ensureTextBlockRemoved(
  filePath: string,
  marker: string
): boolean {
  if (!fs.existsSync(filePath)) return false;
  
  const content = fs.readFileSync(filePath, 'utf-8');
  const escapedMarker = marker.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const blockRegex = new RegExp(
    `\\n?${escapedMarker} >>\\\\n[\\\\s\\\\S]*?\\\\n${escapedMarker} <<\\n?`,
    'g'
  );
  
  const newContent = content.replace(blockRegex, '');
  if (newContent === content) return false;
  
  fs.writeFileSync(filePath, newContent, 'utf-8');
  return true;
}

/**
 * Copy a file from source to destination if it doesn't exist.
 * Returns true if copied, false if already existed.
 */
export function ensureCopied(srcPath: string, destPath: string): boolean {
  if (fs.existsSync(destPath)) return false;
  ensureDir(path.dirname(destPath));
  fs.copyFileSync(srcPath, destPath);
  return true;
}

/**
 * Check if a file exists and contains the given text.
 */
export function fileContains(filePath: string, text: string): boolean {
  if (!fs.existsSync(filePath)) return false;
  const content = fs.readFileSync(filePath, 'utf-8');
  return content.includes(text);
}

/**
 * Read JSON file, returning default if not exists or invalid.
 */
export function readJson<T>(filePath: string, defaultValue: T): T {
  if (!fs.existsSync(filePath)) return defaultValue;
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    return JSON.parse(content) as T;
  } catch {
    return defaultValue;
  }
}

/**
 * Write JSON file with proper formatting.
 */
export function writeJson(filePath: string, data: unknown, indent = 2): void {
  ensureDir(path.dirname(filePath));
  fs.writeFileSync(filePath, JSON.stringify(data, null, indent) + '\n', 'utf-8');
}

/**
 * Find files matching a pattern (simple glob support).
 */
export function findFiles(
  dir: string,
  pattern: RegExp | string,
  options: { recursive?: boolean; excludeDirs?: string[] } = {}
): string[] {
  const { recursive = true, excludeDirs = ['node_modules', '.git', 'target', 'dist'] } = options;
  const results: string[] = [];
  
  const regex = typeof pattern === 'string' 
    ? new RegExp(pattern.replace(/\./g, '\\.').replace(/\*/g, '.*'))
    : pattern;
  
  function scan(currentDir: string): void {
    if (!fs.existsSync(currentDir)) return;
    
    const entries = fs.readdirSync(currentDir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(currentDir, entry.name);
      
      if (entry.isDirectory()) {
        if (recursive && !excludeDirs.includes(entry.name)) {
          scan(fullPath);
        }
      } else if (regex.test(entry.name)) {
        results.push(fullPath);
      }
    }
  }
  
  scan(dir);
  return results;
}
