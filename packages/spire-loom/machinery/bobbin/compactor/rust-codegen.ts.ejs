/**
 * Rust Code Generation
 * "Prisma's SQL, immortalized in Rust."
 */

export function generateRustModule(table, queries) {
  const structName = pascalCase(table.name);
  
  let output = `// Generated by spire-loom prisma-compactor
// "Prisma's optimization, zero runtime overhead"

use std::sync::OnceLock;
use rusqlite::{Connection, Statement, Result, Row};
use serde::{Deserialize, Serialize};

/// ${structName} record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ${structName} {
`;

  // Struct fields
  for (const col of table.columns) {
    const rustType = mapSqlTypeToRust(col.type);
    const fieldType = col.nullable ? `Option<${rustType}>` : rustType;
    output += `    pub ${snakeCase(col.name)}: ${fieldType},\n`;
  }

  output += `}\n\n`;

  // FromRow implementation
  output += `impl ${structName} {\n`;
  output += `    pub fn from_row(row: &Row) -> Result<Self> {\n`;
  output += `        Ok(Self {\n`;
  
  for (const col of table.columns) {
    output += `            ${snakeCase(col.name)}: row.get("${col.name}")?`;
    output += col.nullable ? '.ok()' : '';
    output += `,\n`;
  }
  
  output += `        })\n    }\n}\n\n`;

  // Query functions
  for (const query of queries) {
    output += generateQueryFunction(query, structName, table);
    output += '\n';
  }

  return output;
}

function generateQueryFunction(query, structName, table) {
  const fnName = snakeCase(query.name);
  
  const params = query.params.map(p => {
    const col = table.columns.find(c => c.name === p);
    const rustType = col ? mapSqlTypeToRust(col.type) : 'String';
    return `${snakeCase(p)}: ${rustType}`;
  }).join(', ');

  const isList = query.returnType.includes('Vec');
  const isOptional = query.returnType.includes('Option');
  
  const returnType = isList 
    ? `Result<Vec<${structName}>>`
    : isOptional 
    ? `Result<Option<${structName}>>`
    : `Result<${structName}>`;

  // Escape SQL for Rust raw string
  const escapedSql = query.sql.replace(/\\/g, '\\\\').replace(/"/g, '\\"');

  let output = `/// ${query.name}\n`;
  output += `pub fn ${fnName}(conn: &Connection${params ? ', ' + params : ''}) -> ${returnType} {\n`;
  output += `    static STMT: OnceLock<Statement> = OnceLock::new();\n`;
  output += `    let stmt = STMT.get_or_init(|| {\n`;
  output += `        conn.prepare("${escapedSql}")\n`;
  output += `            .expect("Failed to prepare ${query.name}")\n`;
  output += `    });\n\n`;

  // Execute
  if (query.params.length > 0) {
    const paramRefs = query.params.map(p => `&${snakeCase(p)}`).join(', ');
    output += `    let mut rows = stmt.query(rusqlite::params![${paramRefs}])?;\n`;
  } else {
    output += `    let mut rows = stmt.query([])?;\n`;
  }

  // Return handling
  if (isList) {
    output += `    \n    let mut results = Vec::new();\n`;
    output += `    while let Some(row) = rows.next()? {\n`;
    output += `        results.push(${structName}::from_row(row)?);\n`;
    output += `    }\n`;
    output += `    Ok(results)\n`;
  } else if (isOptional) {
    output += `    \n    match rows.next()? {\n`;
    output += `        Some(row) => Ok(Some(${structName}::from_row(row)?)),\n`;
    output += `        None => Ok(None),\n`;
    output += `    }\n`;
  } else {
    output += `    \n    let row = rows.next()?\n`;
    output += `        .ok_or_else(|| rusqlite::Error::QueryReturnedNoRows)?;\n`;
    output += `    ${structName}::from_row(row)\n`;
  }

  output += `}\n`;
  return output;
}

// Helpers
function mapSqlTypeToRust(sqlType) {
  const map = {
    integer: 'i64',
    text: 'String',
    boolean: 'bool',
    real: 'f64',
    blob: 'Vec<u8>',
    timestamp: 'chrono::DateTime<chrono::Utc>',
    json: 'serde_json::Value',
    datetime: 'chrono::DateTime<chrono::Utc>',
  };
  return map[sqlType] || 'String';
}

function snakeCase(str) {
  return str.replace(/[A-Z]/g, l => `_${l.toLowerCase()}`).replace(/^_/, '');
}

function pascalCase(str) {
  return str.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('');
}
