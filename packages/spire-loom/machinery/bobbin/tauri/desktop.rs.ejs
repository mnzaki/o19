//! Desktop Platform Implementation - GENERATED by spire-loom
//!
//! On desktop, we initialize <%= coreCrateName %> directly and call into it.

use crate::spire::platform::<%= platformTraitName %>;
use crate::spire::error::{Error, Result};
use crate::spire::models::*;
use serde::de::DeserializeOwned;
use std::path::PathBuf;
use tauri::{AppHandle, Manager, Runtime, plugin::PluginApi};

// Import core traits and types needed for method implementations
use <%= crateNaming.rustIdentifier %>::bookmark::BookmarkStream;
use <%= crateNaming.rustIdentifier %>::device::NodeId;
use core::str::FromStr;

/// Initialize the desktop platform.
pub fn init<R: Runtime, C: DeserializeOwned>(
  app: &AppHandle<R>,
  _api: &PluginApi<R, C>,
) -> Result<DesktopPlatform<R>> {
  DesktopPlatform::new(app.clone())
}

/// Desktop platform implementation.
///
/// Holds the <%= coreName %> runtime and provides direct access to all operations.
pub struct DesktopPlatform<R: Runtime> {
  app_handle: AppHandle<R>,
  foundframe: std::sync::Mutex<Option<<%= crateNaming.rustIdentifier %>::Foundframe>>,
}

impl<R: Runtime> DesktopPlatform<R> {
  fn new(app_handle: AppHandle<R>) -> Result<Self> {
    // Initialize <%= coreCrateName %>
    let app_data_dir = app_handle.path().app_data_dir()
      .map_err(|e| Error::Other(format!("Failed to get app data dir: {e}")))?;
    let radicle_home = app_data_dir.join(".<%= coreName %>.radicle");

    let init_options = <%= crateNaming.rustIdentifier %>::InitOptions::new(&radicle_home, "<%= coreName %>")
      .pkb_base(default_pkb_path());

    let foundframe = <%= crateNaming.rustIdentifier %>::init(init_options, None)
      .map_err(|e| Error::Other(format!("Failed to initialize <%= coreCrateName %>: {e}")))?;

    Ok(Self { 
      app_handle,
      foundframe: std::sync::Mutex::new(Some(foundframe)),
    })
  }

  pub fn app_handle(&self) -> &AppHandle<R> {
    &self.app_handle
  }
}

fn default_pkb_path() -> PathBuf {
  PathBuf::from("pkb")
}

impl<R: Runtime> <%= platformTraitName %> for DesktopPlatform<R> {
  fn exit(&self, code: i32) {
    self.app_handle.exit(code);
  }

  fn request_permissions(&self) -> Result<NotificationPermissionStatus> {
    Ok(NotificationPermissionStatus {
      status: "granted".into(),
    })
  }

  fn shutdown(&self) -> Result<()> {
    // TODO: Shutdown <%= coreCrateName %>
    Ok(())
  }

<% methods.forEach(function(method) { -%>
  fn <%= method.name %>(
    &self,
    <% method.params.forEach(function(param, idx) { -%>
    <%= param.name %>: <%- param.rsType %><% if (idx < method.params.length - 1) { %>,<% } %>
    <% }); %>
  ) -> <%- method.useResult ? `Result<${method.innerReturnType}>` : method.rsReturnType %> {
    let guard = self.foundframe.lock().map_err(|_| Error::Other("Foundframe mutex poisoned".into()))?;
    let foundframe = guard.as_ref().ok_or_else(|| Error::Other("Foundframe not initialized".into()))?;
    
<% method.serviceAccessPreamble.forEach(function(line) { -%>
    <%- line %>;
<% }); -%>
    
<% if (method.useResult) { -%>
    // Call the implementation and map errors
    let result: Result<<%- method.innerReturnType %>, <%= crateNaming.rustIdentifier %>::Error> = <%= method.serviceVarName %>.<%= method.implName %>(<% method.params.forEach(function(param, idx) { %>&<%= param.name %><% if (idx < method.params.length - 1) { %>, <% } %><% }); %>);
    result.map_err(|e| Error::Other(e.to_string()))
<% } else { -%>
    // Call the implementation (non-Result, errors ignored/panics)
    <%= method.serviceVarName %>.<%= method.implName %>(<% method.params.forEach(function(param, idx) { %>&<%= param.name %><% if (idx < method.params.length - 1) { %>, <% } %><% }); %>)
<% } -%>
  }

<% }); -%>
}
