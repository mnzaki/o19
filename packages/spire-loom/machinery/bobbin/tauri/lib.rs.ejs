//! <%= pluginName %> - GENERATED by spire-loom
//!
//! Tauri plugin helper for <%= coreName %> platform integration.
//! 
//! Usage in your plugin:
//! ```rust
//! use tauri::plugin::{Builder, TauriPlugin};
//! 
//! pub fn init<R: Runtime>() -> TauriPlugin<R> {
//!   Builder::new("my-plugin")
//!     // Commands are auto-injected by spire-loom into generate_handler!
//!     .invoke_handler(tauri::generate_handler![my_custom_command])
//!     .setup(|app, api| {
//!       // Setup spire platform
//!       let <%= coreName %> = crate::spire::<%= platformSetupFn %>(app, &api)?;
//!       
//!       // Your additional setup...
//!       Ok(())
//!     })
//!     .build()
//! }
//! ```
//!
//! Muxing: This plugin supports multiple platform implementations
//! - #[cfg(desktop)] → DesktopPlatform (direct <%= coreName %> calls)
//! - #[cfg(mobile)] → MobilePlatform (JNI calls to Android service)

use serde::de::DeserializeOwned;
use std::sync::Arc;
use tauri::{
  AppHandle, Manager, Runtime,
  plugin::{Builder, TauriPlugin, PluginApi},
};
use tracing::info;

pub use self::models::*;
pub use self::platform::<%= platformTraitName %>;

pub mod commands;
pub mod error;
pub mod extension;
pub mod models;
pub mod platform;

pub use extension::<%= extensionTraitName %>;
pub use error::{Error, Result};

/// Platform struct that contains all <%= coreName %> state.
/// 
/// This is the main handle users interact with after setup.
pub struct <%= platformStructName %> {
  platform: Arc<dyn <%= platformTraitName %>>,
}

impl <%= platformStructName %> {
  /// Setup the platform and manage it on the app handle.
  /// 
  /// Call this from your plugin's setup function.
  pub fn setup<R: Runtime, C: DeserializeOwned>(
    app: &AppHandle<R>,
    api: &PluginApi<R, C>,
  ) -> Result<Self> {
    info!("Setting up <%= platformStructName %>...");

    // Initialize platform implementation (muxing happens here)
    #[cfg(mobile)]
    let platform = Arc::new(mobile::init(app, api)?) as Arc<dyn <%= platformTraitName %>>;
    #[cfg(desktop)]
    let platform = Arc::new(desktop::init(app, api)?) as Arc<dyn <%= platformTraitName %>>;

    // Manage the platform so extension trait can access it
    app.manage(platform.clone());

    info!("<%= platformStructName %> setup complete");
    Ok(Self { platform })
  }

  /// Get a reference to the platform implementation.
  pub fn platform(&self) -> &dyn <%= platformTraitName %> {
    &*self.platform
  }
}

/// Convenience function for setup.
/// 
/// Returns the platform handle for direct access.
pub fn <%= platformSetupFn %><R: Runtime, C: DeserializeOwned>(
  app: &AppHandle<R>,
  api: &PluginApi<R, C>,
) -> Result<<%= platformStructName %>> {
  <%= platformStructName %>::setup(app, api)
}

// ============================================================================
// Platform-specific implementations
// ============================================================================

#[cfg(desktop)]
mod desktop;
#[cfg(mobile)]
mod mobile;

// ============================================================================
// Mainline Platform Bridge (optional - generated by tauri-desktop-platform treadle)
// ============================================================================

/// Desktop platform bridge implementing mainline Platform trait.
/// 
/// This module provides a bridge between the generated spire platform
/// and the hand-written mainline Platform trait. It delegates CRUD
/// operations to the spire while maintaining mainline compatibility.
#[cfg(desktop)]
pub mod desktop_mainline_bridge;
