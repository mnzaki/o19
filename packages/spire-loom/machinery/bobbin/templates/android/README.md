# Android JNI Templates

## The Handle Pattern

The JNI bridge uses an **opaque handle pattern** for thread-safe access to the Rust core service.

### Architecture Flow

```
Kotlin (JVM)                              Rust (Native)
    │                                          │
    │  nativeStartService(homeDir, alias)      │
    │ ───────────────────────────────────────► │
    │                                          │  initialize_service()
    │ ◄─────────────────────────────────────── │  store in SERVICE_HANDLE
    │           return handleId (1)            │
    │                                          │
    │  nativeGetNodeId(handleId)               │
    │ ───────────────────────────────────────► │
    │                                          │  SERVICE_HANDLE.lock()
    │                                          │  service.get_node_id()
    │ ◄─────────────────────────────────────── │  return result
    │              return String               │  (unlock when guard drops)
```

### Why This Pattern?

**Kotlin cannot directly hold Rust objects.** The JNI boundary requires:

1. **Opaque Handle**: Kotlin holds a `Long` (the handle ID), not an object reference
2. **Native Methods**: Every call must be declared `external` (JNI boundary crossing)
3. **Lock on Rust Side**: The `Mutex` is in Rust, Kotlin knows nothing about it

### The Locking Flow (Per Method Call)

```rust
// 1. JNI function called from Kotlin
pub extern "C" fn Java_..._nativeGetNodeId(
    env: JNIEnv,
    _class: JClass,
    _handle: jlong,  // Kotlin passes handle, we ignore it (use global)
) -> JString {
    
    // 2. Lock the service handle
    let handle = SERVICE_HANDLE.get().unwrap();
    let mut guard = handle.lock().unwrap();
    
    // 3. Call method on locked handle
    let result = guard.get_node_id();
    
    // 4. Convert to JNI type and return
    // (guard drops here, unlocking automatically)
    env.new_string(result).unwrap().into_raw()
}
```

### Kotlin Public API

The Kotlin service provides clean methods that wrap the JNI calls:

```kotlin
class FoundframeService : Service() {
    private var nativeHandle: Long = 0
    
    // Private JNI declaration
    private external fun nativeGetNodeId(handle: Long): String
    
    // Public clean API
    fun getNodeId(): String {
        check(nativeHandle != 0L) { "Service not initialized" }
        return nativeGetNodeId(nativeHandle)
    }
}
```

### Thread Safety

- **Kotlin side**: Methods can be called from any thread (JNI handles this)
- **Rust side**: `Mutex` ensures only one method executes at a time
- **The handle**: Stored in `OnceLock<Arc<Mutex<T>>>` - immutable after init

### Why Not Pass the Handle Through?

The handle ID is currently always `1` (placeholder for future multi-service support).
In a future version, we could support multiple service instances:

```rust
static SERVICE_HANDLES: Mutex<HashMap<jlong, Arc<Mutex<ServiceHandle>>>> = ...;
```

For now, the global static is simpler and sufficient.

---

*Generated by spire-loom. The spiral conserves what matters.*
