//! <%= pluginName %> - GENERATED by spire-loom
//!
//! Tauri plugin with platform abstraction.
//! 
//! Muxing: This plugin aggregates multiple platform implementations
//! and routes to the appropriate one at compile time:
//! - #[cfg(desktop)] → DesktopPlatform (direct <%= coreName %> calls)
//! - #[cfg(mobile)] → MobilePlatform (JNI calls to Android service)
//!
//! Generated from <%= coreName %> Management definitions.

use std::path::PathBuf;
use std::sync::Arc;
use tauri::{
  Emitter, Manager, Runtime,
  plugin::{Builder, TauriPlugin},
};
use tracing::{debug, error, info};

use <%= coreCrateName %>::signal::EventBus;
use <%= coreCrateName %>::thestream::TheStream;

pub use crate::models::*;
pub use crate::platform::Platform;

pub mod commands;
pub mod error;
pub mod models;
pub mod platform;

pub use error::{Error, Result};

/// Application state managed by the plugin.
pub struct AppState {
  /// Platform-specific implementation.
  pub platform: Arc<dyn Platform>,
  /// Event bus for component communication.
  pub events: EventBus,
  /// Database connection.
  pub db: foundframe_to_sql::Database,
  /// Database path for SQL proxy.
  pub db_path: PathBuf,
  /// Handle to keep SQL adapter listener alive.
  #[allow(dead_code)]
  pub _sql_listener: foundframe_to_sql::ListenerHandle,
}

/// Initialize the plugin.
pub fn init<R: Runtime>() -> TauriPlugin<R> {
  Builder::new("<%= pluginName.replace(/-/g, '_') %>")
    .invoke_handler(tauri::generate_handler![
      // Generated commands
<% methods.forEach(function(method) { -%>
      commands::<%= method.name %>,
<% }); -%>
    ])
    .setup(|app, api| {
      <%= coreCrateName %>::setup_logging();
      info!("Initializing <%= pluginName %> plugin...");

      // Register Android plugin (noop on desktop)
      #[cfg(target_os = "android")]
      let plugin_handle = {
        info!("Registering ApiPlugin for Android...");
        api.register_android_plugin("ty.circulari.o19.ff", "ApiPlugin")?
      };
      #[cfg(not(target_os = "android"))]
      let plugin_handle = ();

      // Initialize platform implementation (muxing happens here)
      #[cfg(mobile)]
      let platform = mobile::init(app, api, plugin_handle)?;
      #[cfg(desktop)]
      let platform = desktop::init(app, api)?;

      let app_data_dir = app.path().app_data_dir()?;
      let db_path = app_data_dir.join("<%= coreName %>.db");
      info!("Database path: {:?}", db_path);

      // Initialize database (same on all platforms)
      let db = foundframe_to_sql::Database::open(&db_path)?;
      let sql_adapter =
        foundframe_to_sql::StreamToSql::new(db.clone(), platform.event_bus().clone());
      sql_adapter.migrate()?;
      info!("Database migrations complete");

      // Start SQL adapter listening to events
      let sql_listener = sql_adapter.start();
      info!("SQL adapter started");

      // Clone event bus before moving platform
      let events = platform.event_bus().clone();

      // Set up event forwarding to frontend
      setup_event_forwarding(app, &events)?;

      // Manage all state
      app.manage(AppState {
        platform: Arc::new(platform),
        events,
        db,
        db_path: db_path.clone(),
        _sql_listener: sql_listener,
      });

      info!("<%= pluginName %> plugin initialized successfully");
      Ok(())
    })
    .on_event(|app: &tauri::AppHandle<R>, event| {
      if let tauri::RunEvent::Exit = event {
        info!("Received Exit event, shutting down...");

        if let Some(state) = app.try_state::<AppState>() {
          if let Err(e) = state.platform.shutdown() {
            error!("Error during platform shutdown: {}", e);
          } else {
            info!("Platform shut down successfully");
          }
        }
      }
    })
    .build()
}

/// Set up forwarding of events to the frontend via Tauri events.
fn setup_event_forwarding<R: Runtime>(app: &tauri::AppHandle<R>, events: &EventBus) -> Result<()> {
  use <%= coreCrateName %>::thestream::TheStreamEvent;

  let rx = events.subscribe::<TheStreamEvent>();
  let app_handle = app.clone();

  std::thread::spawn(move || {
    while let Ok(event) = rx.recv() {
      let event_type = match &event {
        TheStreamEvent::ChunkAdded { .. } => "chunk-added",
        TheStreamEvent::EntryPulled { .. } => "entry-pulled",
        TheStreamEvent::ChunkUpdated { .. } => "chunk-updated",
        TheStreamEvent::ChunkRemoved { .. } => "chunk-removed",
        TheStreamEvent::SyncStarted { .. } => "sync-started",
        TheStreamEvent::SyncCompleted { .. } => "sync-completed",
        TheStreamEvent::SyncFailed { .. } => "sync-failed",
      };

      if let Err(e) = app_handle.emit(event_type, event) {
        error!("Failed to emit stream event to frontend: {}", e);
      }
    }
  });

  debug!("Event forwarding to frontend set up");
  Ok(())
}
